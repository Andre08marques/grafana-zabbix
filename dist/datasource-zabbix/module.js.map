{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"react\"","webpack:///external \"lodash\"","webpack:///./datasource-zabbix/utils.ts","webpack:///./datasource-zabbix/constants.ts","webpack:///external \"@grafana/ui\"","webpack:///./datasource-zabbix/types.ts","webpack:///external \"emotion\"","webpack:///external \"moment\"","webpack:///external \"@grafana/runtime\"","webpack:///external \"jquery\"","webpack:///../node_modules/semver/classes/semver.js","webpack:///external \"@grafana/data\"","webpack:///external \"app/plugins/sdk\"","webpack:///external \"app/core/utils/datemath\"","webpack:///../node_modules/semver/functions/compare.js","webpack:///../node_modules/semver/classes/range.js","webpack:///external \"app/core/utils/kbn\"","webpack:///../node_modules/semver/internal/re.js","webpack:///../node_modules/semver/functions/parse.js","webpack:///../node_modules/semver/internal/constants.js","webpack:///../node_modules/semver/internal/debug.js","webpack:///../node_modules/semver/functions/gt.js","webpack:///../node_modules/semver/classes/comparator.js","webpack:///../node_modules/semver/functions/satisfies.js","webpack:///external \"angular\"","webpack:///external \"app/core/core_module\"","webpack:///../node_modules/semver/internal/identifiers.js","webpack:///../node_modules/semver/functions/eq.js","webpack:///../node_modules/semver/functions/compare-build.js","webpack:///../node_modules/semver/functions/lt.js","webpack:///../node_modules/semver/functions/gte.js","webpack:///../node_modules/semver/functions/lte.js","webpack:///../node_modules/semver/ranges/outside.js","webpack:///external \"app/core/core\"","webpack:///external \"app/core/table_model\"","webpack:///../node_modules/semver/functions/neq.js","webpack:///../node_modules/semver/functions/cmp.js","webpack:///external \"app/core/config\"","webpack:///../node_modules/semver/index.js","webpack:///../node_modules/semver/functions/valid.js","webpack:///../node_modules/semver/functions/clean.js","webpack:///../node_modules/semver/functions/inc.js","webpack:///../node_modules/semver/functions/diff.js","webpack:///../node_modules/semver/functions/major.js","webpack:///../node_modules/semver/functions/minor.js","webpack:///../node_modules/semver/functions/patch.js","webpack:///../node_modules/semver/functions/prerelease.js","webpack:///../node_modules/semver/functions/rcompare.js","webpack:///../node_modules/semver/functions/compare-loose.js","webpack:///../node_modules/semver/functions/sort.js","webpack:///../node_modules/semver/functions/rsort.js","webpack:///../node_modules/semver/functions/coerce.js","webpack:///../node_modules/semver/ranges/to-comparators.js","webpack:///../node_modules/semver/ranges/max-satisfying.js","webpack:///../node_modules/semver/ranges/min-satisfying.js","webpack:///../node_modules/semver/ranges/min-version.js","webpack:///../node_modules/semver/ranges/valid.js","webpack:///../node_modules/semver/ranges/gtr.js","webpack:///../node_modules/semver/ranges/ltr.js","webpack:///../node_modules/semver/ranges/intersects.js","webpack:///../node_modules/semver/ranges/simplify.js","webpack:///../node_modules/semver/ranges/subset.js","webpack:///./datasource-zabbix/migrations.ts","webpack:///./datasource-zabbix/metricFunctions.ts","webpack:///./datasource-zabbix/timeseries.ts","webpack:///./datasource-zabbix/dataProcessor.ts","webpack:///./datasource-zabbix/responseHandler.ts","webpack:///./datasource-zabbix/problemsHandler.ts","webpack:///./datasource-zabbix/zabbix/proxy/cachingProxy.ts","webpack:///./datasource-zabbix/zabbix/connectors/dbConnector.js","webpack:///./datasource-zabbix/zabbix/connectors/zabbix_api/zabbixAPICore.ts","webpack:///./datasource-zabbix/zabbix/connectors/zabbix_api/zabbixAPIConnector.ts","webpack:///./datasource-zabbix/zabbix/connectors/sql/mysql.js","webpack:///./datasource-zabbix/zabbix/connectors/sql/postgres.js","webpack:///./datasource-zabbix/zabbix/connectors/sql/sqlConnector.js","webpack:///./datasource-zabbix/zabbix/connectors/influxdb/influxdbConnector.js","webpack:///./datasource-zabbix/zabbix/zabbix.ts","webpack:///./datasource-zabbix/datasource.ts","webpack:///./datasource-zabbix/query.controller.js","webpack:///./datasource-zabbix/config.controller.js","webpack:///./datasource-zabbix/components/ZabbixInput.tsx","webpack:///./datasource-zabbix/components/VariableQueryEditor.tsx","webpack:///./datasource-zabbix/zabbixAlerting.service.js","webpack:///./datasource-zabbix/add-metric-function.directive.js","webpack:///./datasource-zabbix/react2angular.ts","webpack:///./datasource-zabbix/components/FunctionEditorControls.tsx","webpack:///./datasource-zabbix/components/FunctionEditor.tsx","webpack:///./datasource-zabbix/metric-function-editor.directive.ts","webpack:///./datasource-zabbix/module.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","variableRegex","expandItemName","paramStr","params","quoted","in_array","param","key_params_str","substring","indexOf","lastIndexOf","key_params","forEach","symbol","push","length","replace","expandItems","items","item","key_","MACRO_PATTERN","containsMacro","itemName","test","replaceMacro","macros","isTriggerItem","url","item_macros","match","macro","host_macros","filter","hostid","hosts","h","macro_def","find","macro_value","macro_regex","RegExp","escapeMacro","parseLegacyVariableQuery","query","queryType","parts","each","split","isContainsBraces","result","map","part","trim","splitTemplateQuery","template","zipObject","app","Group","Host","Application","Item","group","host","application","regexPattern","isRegex","str","isTemplateVariable","templateVariables","variables","variable","includes","getRangeScopedVars","range","msRange","to","diff","from","sRange","Math","round","regularRange","secondsToHms","__range_ms","text","__range_s","__range","__range_series","buildRegex","matches","pattern","flags","undefined","escapeRegex","parseInterval","interval","momentInterval","exec","duration","Number","valueOf","parseTimeShiftInterval","formatAcknowledges","acknowledges","ack","unix","clock","format","alias","surname","message","concat","sequence","funcsArray","this","compactQuery","getArrayDepth","a","level","elem","isArray","isNumeric","isNaN","parseFloat","isFinite","parseTags","tagStr","tags","tag","tagParts","mustArray","ZABBIX_PROBLEMS_PANEL_ID","DATAPOINT_TS","MODE_METRICS","MODE_ITSERVICE","MODE_TEXT","MODE_ITEMID","MODE_TRIGGERS","MODE_PROBLEMS","SEV_WARNING","ZBX_ACK_ACTION_NONE","ZBX_ACK_ACTION_CLOSE","ZBX_ACK_ACTION_ACK","ZBX_ACK_ACTION_ADD_MESSAGE","ZBX_ACK_ACTION_CHANGE_SEVERITY","TRIGGER_SEVERITY","val","MIN_SLA_INTERVAL","RANGE_VARIABLE_VALUE","DEFAULT_ZABBIX_PROBLEMS_LIMIT","__WEBPACK_EXTERNAL_MODULE__5__","VariableQueryTypes","ShowProblemTypes","__WEBPACK_EXTERNAL_MODULE__8__","__WEBPACK_EXTERNAL_MODULE__9__","__WEBPACK_EXTERNAL_MODULE__10__","__WEBPACK_EXTERNAL_MODULE__11__","debug","require","MAX_LENGTH","MAX_SAFE_INTEGER","re","compareIdentifiers","SemVer","version","options","loose","includePrerelease","TypeError","LOOSE","FULL","raw","major","minor","patch","prerelease","id","num","build","join","other","compareMain","comparePre","b","release","identifier","inc","Error","__WEBPACK_EXTERNAL_MODULE__13__","__WEBPACK_EXTERNAL_MODULE__14__","__WEBPACK_EXTERNAL_MODULE__15__","compare","Range","Comparator","set","parseRange","comps","hr","HYPHENRANGELOOSE","HYPHENRANGE","hyphenReplace","COMPARATORTRIM","comparatorTrimReplace","TILDETRIM","tildeTrimReplace","CARETTRIM","caretTrimReplace","compRe","COMPARATORLOOSE","COMPARATOR","comp","parseComparator","replaceGTE0","some","thisComparators","isSatisfiable","rangeComparators","every","thisComparator","rangeComparator","intersects","er","testSet","comparators","remainingComparators","slice","testComparator","pop","otherComparator","replaceCarets","replaceTildes","replaceXRanges","replaceStars","isX","toLowerCase","replaceTilde","TILDELOOSE","TILDE","_","M","pr","ret","replaceCaret","CARETLOOSE","CARET","z","replaceXRange","XRANGELOOSE","XRANGE","gtlt","xM","xm","xp","anyX","STAR","GTE0PRE","GTE0","incPr","$0","fM","fm","fp","fpr","fb","tM","tm","tp","tpr","tb","semver","ANY","allowed","__WEBPACK_EXTERNAL_MODULE__19__","MAX_SAFE_COMPONENT_LENGTH","src","R","createToken","isGlobal","index","NUMERICIDENTIFIER","NUMERICIDENTIFIERLOOSE","NONNUMERICIDENTIFIER","PRERELEASEIDENTIFIER","PRERELEASEIDENTIFIERLOOSE","BUILDIDENTIFIER","MAINVERSION","PRERELEASE","BUILD","FULLPLAIN","MAINVERSIONLOOSE","PRERELEASELOOSE","LOOSEPLAIN","XRANGEIDENTIFIER","XRANGEIDENTIFIERLOOSE","GTLT","XRANGEPLAIN","XRANGEPLAINLOOSE","COERCE","LONETILDE","LONECARET","SEMVER_SPEC_VERSION","process","env","NODE_DEBUG","args","console","error","parse","operator","cmp","sameDirectionIncreasing","sameDirectionDecreasing","sameSemVer","differentDirectionsInclusive","oppositeDirectionsLessThan","oppositeDirectionsGreaterThan","__WEBPACK_EXTERNAL_MODULE__28__","__WEBPACK_EXTERNAL_MODULE__29__","numeric","anum","bnum","rcompareIdentifiers","versionA","versionB","compareBuild","satisfies","gt","lt","lte","gte","hilo","gtfn","ltefn","ltfn","ecomp","high","low","comparator","__WEBPACK_EXTERNAL_MODULE__37__","__WEBPACK_EXTERNAL_MODULE__38__","eq","neq","op","__WEBPACK_EXTERNAL_MODULE__42__","internalRe","tokens","valid","clean","rcompare","compareLoose","sort","rsort","coerce","toComparators","maxSatisfying","minSatisfying","minVersion","validRange","outside","gtr","ltr","simplifyRange","subset","v","version1","version2","v1","v2","hasPre","prefix","defaultResult","parsed","list","String","rtl","next","COERCERTL","lastIndex","versions","max","maxSV","rangeObj","min","minSV","minver","compver","r1","r2","prev","ranges","simplified","original","simpleSubset","sub","dom","gtltComp","eqSet","Set","higherGT","lowerLT","add","size","hasDomLT","hasDomGT","sawNonNull","OUTER","simpleSub","simpleDom","isSub","target","f","def","jsonData","dbConnection","funcDef","type","func","paramType","strValue","datapoints","point","timestamp","ms_interval","series","left","right","time_to","timeWindow","groupBy","interpolated_timeseries","j","ema","values","values_non_null","partial","aggregateWrapper","setAlias","dp","itemid","scopedVars","extractedValue","addHostName","convertText","table","addColumn","e","trigger","triggerFilter","cacheOptions","self","cache","funcName","promises","promiseKeeper","hash","HISTORY_TO_TABLE_MAP","datasourceId","datasourceName","datasourceTypeId","datasourceTypeName","DBConnector","then","ds","meta","convertGrafanaTSResponse","history","methodName","code","grafanaSeries","compact","DEFAULT_QUERY_LIMIT","TREND_TO_TABLE_MAP","consolidateByFunc","consolidateByTrendColumns","withCredentials","loginErrorCount","loginPromise","getVersionPromise","action","applicationids","timeRange","historyQuery","trendsQuery","itemids","timeFrom","timeTill","intervalSec","testQuery","ITEMID_FORMAT","time_expression","mysql","sqlDialect","postgres","invokeSQLQuery","intervalMs","consolidateBy","numOfIntervals","grouped_items","value_type","results","valueColumn","dbConnector","refId","rawSql","maxDataPoints","method","data","queries","Promise","reject","buildHistoryQuery","invokeInfluxDBQuery","handleInfluxHistoryResponse","influxSeries","points","retentionPolicy","measurement","where_clause","itemidsWhere","cachingProxy","proxyfyWithCache","initDBConnector","testDataSource","filters","apps","getAllHosts","groupFilter","getAllApps","getApps","appsResponse","hostids","getAllItems","getItemValues","getProblems","hostFilter","triggers","getProblemsHistory","getHistoryTS","getTrends","finded","templateSrv","zabbixAlertingSrv","trends","bindFunctionDefs","functions","itservices","replaceTemplateVars","problems","zabbix","annotation","annotationTags","expression","metricObj","replacedTarget","editorModes","$scope","editorMode","ITSERVICE","ITEMID","TRIGGERS","PROBLEMS","slaPropertyList","slaIntervals","ackFilters","problemAckFilters","showEventsFields","showProblemsOptions","resultFormats","getGroupNames","getItemNames","getMetricNames","getITServices","getProxyNames","getVariables","getTemplateVariables","$rootScope","onVariableChange","init","migrations","metric","queryOptionsText","scopeDefaults","getTargetDefaults","proxy","showDisabledItems","skipEmptyValues","slaInterval","minSeverity","sortProblems","acknowledged","hostsInMaintenance","hostProxy","limit","initFilters","suggestITServices","$injector","suggestGroups","suggestHosts","suggestApps","suggestItems","all","addAllValue","metrics","getAllGroups","groups","hostList","appList","appFilter","itemtype","getProxies","proxies","proxyList","utils","newTarget","targetChanged","isContainsVariables","field","newFunc","metricFunctions","moveAliasFuncLast","offset","aliasFunc","showQueryOptions","renderQueryOptionsText","metricOptionsMap","optionsMap","problemsOptionsMap","optionValue","dbConnectionDatasourceId","alerting","addThresholds","alertingMinSeverity","disableReadOnlyUsersAck","ZabbixDSConfigController","current","getSupportedDBDataSources","getDataSourceSrv","getAll","dsId","dsName","dbConnectionDatasourceName","inputClass","styles","label","state","className","getDashboardModel","angular","alertState","panelIndex","panelModels","alertClass","$","panelContainers","getPanelModels","panelId","threshold","containsThreshold","panel","thresholdOptions","colorMode","line","lineColor","source","thresholds","inputTemplate","functionMenu","createFunctionDropDownMenu","$input","appendTo","submenu","click","typeahead","allFunctions","updater","$button","keyup","toggleClass","blur","removeClass","$compile","contents","$link","paramValue","component"],"mappings":"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","file":"datasource-zabbix/module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 76);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","import _ from 'lodash';\nimport moment from 'moment';\nimport kbn from 'grafana/app/core/utils/kbn';\nimport * as c from './constants';\nimport { VariableQuery, VariableQueryTypes } from './types';\n\n/*\n * This regex matches 3 types of variable reference with an optional format specifier\n * \\$(\\w+)                          $var1\n * \\[\\[([\\s\\S]+?)(?::(\\w+))?\\]\\]    [[var2]] or [[var2:fmt2]]\n * \\${(\\w+)(?::(\\w+))?}             ${var3} or ${var3:fmt3}\n */\nexport const variableRegex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)(?::(\\w+))?\\]\\]|\\${(\\w+)(?:\\.([^:^\\}]+))?(?::(\\w+))?}/g;\n\n/**\n * Expand Zabbix item name\n *\n * @param  {string} name item name, ie \"CPU $2 time\"\n * @param  {string} key  item key, ie system.cpu.util[,system,avg1]\n * @return {string}      expanded name, ie \"CPU system time\"\n */\nexport function expandItemName(name: string, key: string): string {\n\n  // extract params from key:\n  // \"system.cpu.util[,system,avg1]\" --> [\"\", \"system\", \"avg1\"]\n  const key_params_str = key.substring(key.indexOf('[') + 1, key.lastIndexOf(']'));\n  const key_params = splitKeyParams(key_params_str);\n\n  // replace item parameters\n  for (let i = key_params.length; i >= 1; i--) {\n    name = name.replace('$' + i, key_params[i - 1]);\n  }\n  return name;\n}\n\nexport function expandItems(items) {\n  _.forEach(items, item => {\n    item.item = item.name;\n    item.name = expandItemName(item.item, item.key_);\n    return item;\n  });\n  return items;\n}\n\nfunction splitKeyParams(paramStr) {\n  const params = [];\n  let quoted = false;\n  let in_array = false;\n  const split_symbol = ',';\n  let param = '';\n\n  _.forEach(paramStr, symbol => {\n    if (symbol === '\"' && in_array) {\n      param += symbol;\n    } else if (symbol === '\"' && quoted) {\n      quoted = false;\n    } else if (symbol === '\"' && !quoted) {\n      quoted = true;\n    } else if (symbol === '[' && !quoted) {\n      in_array  = true;\n    } else if (symbol === ']' && !quoted) {\n      in_array = false;\n    } else if (symbol === split_symbol && !quoted && !in_array) {\n      params.push(param);\n      param = '';\n    } else {\n      param += symbol;\n    }\n  });\n\n  params.push(param);\n  return params;\n}\n\nconst MACRO_PATTERN = /{\\$[A-Z0-9_\\.]+}/g;\n\nexport function containsMacro(itemName) {\n  return MACRO_PATTERN.test(itemName);\n}\n\nexport function replaceMacro(item, macros, isTriggerItem?) {\n  let itemName = isTriggerItem ? item.url : item.name;\n  const item_macros = itemName.match(MACRO_PATTERN);\n  _.forEach(item_macros, macro => {\n    const host_macros = _.filter(macros, m => {\n      if (m.hostid) {\n        if (isTriggerItem) {\n          // Trigger item can have multiple hosts\n          // Check all trigger host ids against macro host id\n          let hostIdFound = false;\n          _.forEach(item.hosts, h => {\n            if (h.hostid === m.hostid) {\n              hostIdFound = true;\n            }\n          });\n          return hostIdFound;\n        } else {\n          // Check app host id against macro host id\n          return m.hostid === item.hostid;\n        }\n      } else {\n        // Add global macros\n        return true;\n      }\n    });\n\n    const macro_def = _.find(host_macros, { macro: macro });\n    if (macro_def && macro_def.value) {\n      const macro_value = macro_def.value;\n      const macro_regex = new RegExp(escapeMacro(macro));\n      itemName = itemName.replace(macro_regex, macro_value);\n    }\n  });\n\n  return itemName;\n}\n\nfunction escapeMacro(macro) {\n  macro = macro.replace(/\\$/, '\\\\\\$');\n  return macro;\n}\n\nexport function parseLegacyVariableQuery(query: string): VariableQuery {\n  let queryType: VariableQueryTypes;\n  const parts = [];\n\n  // Split query. Query structure: group.host.app.item\n  _.each(splitTemplateQuery(query), part => {\n    // Replace wildcard to regex\n    if (part === '*') {\n      part = '/.*/';\n    }\n    parts.push(part);\n  });\n  const template = _.zipObject(['group', 'host', 'app', 'item'], parts);\n\n  if (parts.length === 4 && template.app === '/.*/') {\n    // Search for all items, even it's not belong to any application\n    template.app = '';\n  }\n\n  switch (parts.length) {\n    case 1:\n      queryType = VariableQueryTypes.Group;\n      break;\n    case 2:\n      queryType = VariableQueryTypes.Host;\n      break;\n    case 3:\n      queryType = VariableQueryTypes.Application;\n      break;\n    case 4:\n      queryType = VariableQueryTypes.Item;\n      break;\n  }\n\n  const variableQuery: VariableQuery = {\n    queryType,\n    group: template.group || '',\n    host: template.host || '',\n    application: template.app || '',\n    item: template.item || '',\n  };\n\n  return variableQuery;\n}\n\n/**\n * Split template query to parts of zabbix entities\n * group.host.app.item -> [group, host, app, item]\n * {group}{host.com} -> [group, host.com]\n */\nexport function splitTemplateQuery(query) {\n  const splitPattern = /\\{[^\\{\\}]*\\}|\\{\\/.*\\/\\}/g;\n  let split;\n\n  if (isContainsBraces(query)) {\n    const result = query.match(splitPattern);\n    split = _.map(result, part => {\n      return _.trim(part, '{}');\n    });\n  } else {\n    split = query.split('.');\n  }\n\n  return split;\n}\n\nfunction isContainsBraces(query) {\n  const bracesPattern = /^\\{.+\\}$/;\n  return bracesPattern.test(query);\n}\n\n// Pattern for testing regex\nexport const regexPattern = /^\\/(.*)\\/([gmi]*)$/m;\n\nexport function isRegex(str) {\n  return regexPattern.test(str);\n}\n\nexport function isTemplateVariable(str, templateVariables) {\n  const variablePattern = /^\\$\\w+/;\n  if (variablePattern.test(str)) {\n    const variables = _.map(templateVariables, variable => {\n      return '$' + variable.name;\n    });\n    return _.includes(variables, str);\n  } else {\n    return false;\n  }\n}\n\nexport function getRangeScopedVars(range) {\n  const msRange = range.to.diff(range.from);\n  const sRange = Math.round(msRange / 1000);\n  const regularRange = kbn.secondsToHms(msRange / 1000);\n  return {\n    __range_ms: { text: msRange, value: msRange },\n    __range_s: { text: sRange, value: sRange },\n    __range: { text: regularRange, value: regularRange },\n    __range_series: {text: c.RANGE_VARIABLE_VALUE, value: c.RANGE_VARIABLE_VALUE},\n  };\n}\n\nexport function buildRegex(str) {\n  const matches = str.match(regexPattern);\n  const pattern = matches[1];\n  const flags = matches[2] !== \"\" ? matches[2] : undefined;\n  return new RegExp(pattern, flags);\n}\n\n// Need for template variables replace\n// From Grafana's templateSrv.js\nexport function escapeRegex(value) {\n  return value.replace(/[\\\\^$*+?.()|[\\]{}\\/]/g, '\\\\$&');\n}\n\nexport function parseInterval(interval: string): number {\n  const intervalPattern = /(^[\\d]+)(y|M|w|d|h|m|s)/g;\n  const momentInterval: any[] = intervalPattern.exec(interval);\n  const duration = moment.duration(Number(momentInterval[1]), momentInterval[2]);\n  return (duration.valueOf() as number);\n}\n\nexport function parseTimeShiftInterval(interval) {\n  const intervalPattern = /^([\\+\\-]*)([\\d]+)(y|M|w|d|h|m|s)/g;\n  const momentInterval: any[] = intervalPattern.exec(interval);\n  let duration: any = 0;\n\n  if (momentInterval[1] === '+') {\n    duration = 0 - (moment.duration(Number(momentInterval[2]), momentInterval[3]).valueOf() as any);\n  } else {\n    duration = moment.duration(Number(momentInterval[2]), momentInterval[3]).valueOf();\n  }\n\n  return duration;\n}\n\n/**\n * Format acknowledges.\n *\n * @param  {array} acknowledges array of Zabbix acknowledge objects\n * @return {string} HTML-formatted table\n */\nexport function formatAcknowledges(acknowledges) {\n  if (acknowledges.length) {\n    let formatted_acknowledges = '<br><br>Acknowledges:<br><table><tr><td><b>Time</b></td>'\n      + '<td><b>User</b></td><td><b>Comments</b></td></tr>';\n    _.each(_.map(acknowledges, ack => {\n      const timestamp = moment.unix(ack.clock);\n      return '<tr><td><i>' + timestamp.format(\"DD MMM YYYY HH:mm:ss\") + '</i></td><td>' + ack.alias\n        + ' (' + ack.name + ' ' + ack.surname + ')' + '</td><td>' + ack.message + '</td></tr>';\n    }), ack => {\n      formatted_acknowledges = formatted_acknowledges.concat(ack);\n    });\n    formatted_acknowledges = formatted_acknowledges.concat('</table>');\n    return formatted_acknowledges;\n  } else {\n    return '';\n  }\n}\n\nexport function convertToZabbixAPIUrl(url) {\n  const zabbixAPIUrlPattern = /.*api_jsonrpc.php$/;\n  const trimSlashPattern = /(.*?)[\\/]*$/;\n  if (url.match(zabbixAPIUrlPattern)) {\n    return url;\n  } else {\n    return url.replace(trimSlashPattern, \"$1\");\n  }\n}\n\n/**\n * Wrap function to prevent multiple calls\n * when waiting for result.\n */\nexport function callOnce(func, promiseKeeper) {\n  return function() {\n    if (!promiseKeeper) {\n      promiseKeeper = Promise.resolve(\n        func.apply(this, arguments)\n        .then(result => {\n          promiseKeeper = null;\n          return result;\n        })\n      );\n    }\n    return promiseKeeper;\n  };\n}\n\n/**\n * Apply function one by one: `sequence([a(), b(), c()]) = c(b(a()))`\n * @param {*} funcsArray functions to apply\n */\nexport function sequence(funcsArray) {\n  return function(result) {\n    for (let i = 0; i < funcsArray.length; i++) {\n      result = funcsArray[i].call(this, result);\n    }\n    return result;\n  };\n}\n\nconst versionPattern = /^(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?(?:-([0-9A-Za-z\\.]+))?/;\n\nexport function isValidVersion(version) {\n  return versionPattern.exec(version);\n}\n\nexport function parseVersion(version: string) {\n  const match = versionPattern.exec(version);\n  if (!match) {\n    return null;\n  }\n  const major = Number(match[1]);\n  const minor = Number(match[2] || 0);\n  const patch = Number(match[3] || 0);\n  const meta = match[4];\n  return { major, minor, patch, meta };\n}\n\n/**\n * Replaces any space-like symbols (tabs, new lines, spaces) by single whitespace.\n */\nexport function compactQuery(query) {\n  return query.replace(/\\s+/g, ' ').trim();\n}\n\nexport function getArrayDepth(a, level = 0) {\n  if (a.length === 0) {\n    return 1;\n  }\n  const elem = a[0];\n  if (_.isArray(elem)) {\n    return getArrayDepth(elem, level + 1);\n  }\n  return level + 1;\n}\n\n/**\n * Checks whether its argument represents a numeric value.\n */\nexport function isNumeric(n: any): boolean {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Parses tags string into array of {tag: value} objects\n */\nexport function parseTags(tagStr: string): any[] {\n  if (!tagStr) {\n    return [];\n  }\n\n  let tags: any[] = _.map(tagStr.split(','), (tag) => tag.trim());\n  tags = _.map(tags, (tag) => {\n    const tagParts = tag.split(':');\n    return {tag: tagParts[0].trim(), value: tagParts[1].trim()};\n  });\n  return tags;\n}\n\nexport function mustArray(result: any): any[] {\n  return result || [];\n}\n","// Plugin IDs\nexport const ZABBIX_PROBLEMS_PANEL_ID = 'alexanderzobnin-zabbix-triggers-panel';\nexport const ZABBIX_DS_ID = 'alexanderzobnin-zabbix-datasource';\n\n// Data point\nexport const DATAPOINT_VALUE = 0;\nexport const DATAPOINT_TS = 1;\n\n// Editor modes\nexport const MODE_METRICS = 0;\nexport const MODE_ITSERVICE = 1;\nexport const MODE_TEXT = 2;\nexport const MODE_ITEMID = 3;\nexport const MODE_TRIGGERS = 4;\nexport const MODE_PROBLEMS = 5;\n\n// Triggers severity\nexport const SEV_NOT_CLASSIFIED = 0;\nexport const SEV_INFORMATION = 1;\nexport const SEV_WARNING = 2;\nexport const SEV_AVERAGE = 3;\nexport const SEV_HIGH = 4;\nexport const SEV_DISASTER = 5;\n\nexport const SHOW_ALL_TRIGGERS = [0, 1];\nexport const SHOW_ALL_EVENTS = [0, 1];\nexport const SHOW_OK_EVENTS = 1;\n\n// Acknowledge\nexport const ZBX_ACK_ACTION_NONE = 0;\nexport const ZBX_ACK_ACTION_CLOSE = 1;\nexport const ZBX_ACK_ACTION_ACK = 2;\nexport const ZBX_ACK_ACTION_ADD_MESSAGE = 4;\nexport const ZBX_ACK_ACTION_CHANGE_SEVERITY = 8;\n\nexport const TRIGGER_SEVERITY = [\n  {val: 0, text: 'Not classified'},\n  {val: 1, text: 'Information'},\n  {val: 2, text: 'Warning'},\n  {val: 3, text: 'Average'},\n  {val: 4, text: 'High'},\n  {val: 5, text: 'Disaster'}\n];\n\n/** Minimum interval for SLA over time (1 hour) */\nexport const MIN_SLA_INTERVAL = 3600;\n\nexport const RANGE_VARIABLE_VALUE = 'range_series';\n\nexport const DEFAULT_ZABBIX_PROBLEMS_LIMIT = 1001;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","import { SelectableValue } from \"@grafana/data\";\n\nexport interface VariableQueryProps {\n  query: LegacyVariableQuery;\n  onChange: (query: VariableQuery, definition: string) => void;\n  datasource: any;\n  templateSrv: any;\n}\n\nexport interface VariableQueryData extends VariableQuery {\n  selectedQueryType: SelectableValue<VariableQueryTypes>;\n  legacyQuery?: string;\n}\n\nexport interface VariableQuery {\n  queryType: VariableQueryTypes;\n  group?: string;\n  host?: string;\n  application?: string;\n  item?: string;\n}\n\nexport type LegacyVariableQuery = VariableQuery | string;\n\nexport enum VariableQueryTypes {\n  Group = 'group',\n  Host = 'host',\n  Application = 'application',\n  Item = 'item',\n  ItemValues = 'itemValues',\n}\n\nexport enum ShowProblemTypes {\n  Problems = 'problems',\n  Recent = 'recent',\n  History = 'history',\n}\n\nexport interface ProblemDTO {\n  triggerid?: string;\n  eventid?: string;\n  timestamp: number;\n\n  /** Name of the trigger. */\n  name?: string;\n\n  /** Same as a name. */\n  description?: string;\n\n  /** Whether the trigger is in OK or problem state. */\n  value?: string;\n\n  datasource?: string;\n  comments?: string;\n  host?: string;\n  hostTechName?: string;\n  proxy?: string;\n  severity?: string;\n\n  acknowledged?: '1' | '0';\n  acknowledges?: ZBXAcknowledge[];\n\n  groups?: ZBXGroup[];\n  hosts?: ZBXHost[];\n  items?: ZBXItem[];\n  alerts?: ZBXAlert[];\n  tags?: ZBXTag[];\n  url?: string;\n\n  expression?: string;\n  correlation_mode?: string;\n  correlation_tag?: string;\n  suppressed?: string;\n  suppression_data?: any[];\n  state?: string;\n  maintenance?: boolean;\n  manual_close?: string;\n  error?: string;\n\n  showAckButton?: boolean;\n}\n\nexport interface ZBXProblem {\n  acknowledged?: '1' | '0';\n  acknowledges?: ZBXAcknowledge[];\n  clock: string;\n  ns: string;\n  correlationid?: string;\n  datasource?: string;\n  name?: string;\n  eventid?: string;\n  maintenance?: boolean;\n  object?: string;\n  objectid?: string;\n  opdata?: any;\n  r_eventid?: string;\n  r_clock?: string;\n  r_ns?: string;\n  severity?: string;\n  showAckButton?: boolean;\n  source?: string;\n  suppressed?: string;\n  suppression_data?: any[];\n  tags?: ZBXTag[];\n  userid?: string;\n}\n\nexport interface ZBXTrigger {\n  acknowledges?: ZBXAcknowledge[];\n  showAckButton?: boolean;\n  alerts?: ZBXAlert[];\n  age?: string;\n  color?: string;\n  comments?: string;\n  correlation_mode?: string;\n  correlation_tag?: string;\n  datasource?: string;\n  description?: string;\n  error?: string;\n  expression?: string;\n  flags?: string;\n  groups?: ZBXGroup[];\n  host?: string;\n  hostTechName?: string;\n  hosts?: ZBXHost[];\n  items?: ZBXItem[];\n  lastEvent?: ZBXEvent;\n  lastchange?: string;\n  lastchangeUnix?: number;\n  maintenance?: boolean;\n  manual_close?: string;\n  priority?: string;\n  proxy?: string;\n  recovery_expression?: string;\n  recovery_mode?: string;\n  severity?: string;\n  state?: string;\n  status?: string;\n  tags?: ZBXTag[];\n  templateid?: string;\n  triggerid?: string;\n  /** Whether the trigger can generate multiple problem events. */\n  type?: string;\n  url?: string;\n  value?: string;\n}\n\nexport interface ZBXGroup {\n  groupid: string;\n  name: string;\n}\n\nexport interface ZBXHost {\n  hostid: string;\n  name: string;\n  host: string;\n  maintenance_status?: string;\n  proxy_hostid?: string;\n}\n\nexport interface ZBXItem {\n  itemid: string;\n  name: string;\n  key_: string;\n  lastvalue?: string;\n}\n\nexport interface ZBXEvent {\n  eventid: string;\n  clock: string;\n  ns?: string;\n  value?: string;\n  name?: string;\n  source?: string;\n  object?: string;\n  objectid?: string;\n  severity?: string;\n  hosts?: ZBXHost[];\n  acknowledged?: '1' | '0';\n  acknowledges?: ZBXAcknowledge[];\n  tags?: ZBXTag[];\n  suppressed?: string;\n}\n\nexport interface ZBXTag {\n  tag: string;\n  value?: string;\n}\n\nexport interface ZBXAcknowledge {\n  acknowledgeid: string;\n  eventid: string;\n  userid: string;\n  action: string;\n  clock: string;\n  time: string;\n  message?: string;\n  user: string;\n  alias: string;\n  name: string;\n  surname: string;\n}\n\nexport interface ZBXAlert {\n  eventid: string;\n  clock: string;\n  message: string;\n  error: string;\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__8__;","module.exports = __WEBPACK_EXTERNAL_MODULE__9__;","module.exports = __WEBPACK_EXTERNAL_MODULE__10__;","module.exports = __WEBPACK_EXTERNAL_MODULE__11__;","const debug = require('../internal/debug')\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')\nconst { re, t } = require('../internal/re')\n\nconst { compareIdentifiers } = require('../internal/identifiers')\nclass SemVer {\n  constructor (version, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier)\n        this.inc('pre', identifier)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier)\n        }\n        this.inc('pre', identifier)\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre':\n        if (this.prerelease.length === 0) {\n          this.prerelease = [0]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            this.prerelease.push(0)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          if (this.prerelease[0] === identifier) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = [identifier, 0]\n            }\n          } else {\n            this.prerelease = [identifier, 0]\n          }\n        }\n        break\n\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.format()\n    this.raw = this.version\n    return this\n  }\n}\n\nmodule.exports = SemVer\n","module.exports = __WEBPACK_EXTERNAL_MODULE__13__;","module.exports = __WEBPACK_EXTERNAL_MODULE__14__;","module.exports = __WEBPACK_EXTERNAL_MODULE__15__;","const SemVer = require('../classes/semver')\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n","// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.format()\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First, split based on boolean or ||\n    this.raw = range\n    this.set = range\n      .split(/\\s*\\|\\|\\s*/)\n      // map the range to a 2d array of comparators\n      .map(range => this.parseRange(range.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${range}`)\n    }\n\n    this.format()\n  }\n\n  format () {\n    this.range = this.set\n      .map((comps) => {\n        return comps.join(' ').trim()\n      })\n      .join('||')\n      .trim()\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    const loose = this.options.loose\n    range = range.trim()\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range, re[t.COMPARATORTRIM])\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n\n    // normalize spaces\n    range = range.split(/\\s+/).join(' ')\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    return range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      .map(comp => replaceGTE0(comp, this.options))\n      // in loose mode, throw out any that are not valid comparators\n      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)\n      .map(comp => new Comparator(comp, this.options))\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\nmodule.exports = Range\n\nconst Comparator = require('./comparator')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst {\n  re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace\n} = require('../internal/re')\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\nconst replaceTildes = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceTilde(comp, options)\n  }).join(' ')\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\nconst replaceCarets = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceCaret(comp, options)\n  }).join(' ')\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map((comp) => {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<')\n        pr = '-0'\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp.trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return (`${from} ${to}`).trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__19__;","const { MAX_SAFE_COMPONENT_LENGTH } = require('./constants')\nconst debug = require('./debug')\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst src = exports.src = []\nconst t = exports.t = {}\nlet R = 0\n\nconst createToken = (name, value, isGlobal) => {\n  const index = R++\n  debug(index, value)\n  t[name] = index\n  src[index] = value\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*')\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCE', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\.0\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\.0\\.0-0\\\\s*$')\n","const {MAX_LENGTH} = require('../internal/constants')\nconst { re, t } = require('../internal/re')\nconst SemVer = require('../classes/semver')\n\nconst parse = (version, options) => {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  const r = options.loose ? re[t.LOOSE] : re[t.FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nmodule.exports = parse\n","// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\nmodule.exports = {\n  SEMVER_SPEC_VERSION,\n  MAX_LENGTH,\n  MAX_SAFE_INTEGER,\n  MAX_SAFE_COMPONENT_LENGTH\n}\n","const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n","const compare = require('./compare')\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n","const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n  constructor (comp, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    const sameDirectionIncreasing =\n      (this.operator === '>=' || this.operator === '>') &&\n      (comp.operator === '>=' || comp.operator === '>')\n    const sameDirectionDecreasing =\n      (this.operator === '<=' || this.operator === '<') &&\n      (comp.operator === '<=' || comp.operator === '<')\n    const sameSemVer = this.semver.version === comp.semver.version\n    const differentDirectionsInclusive =\n      (this.operator === '>=' || this.operator === '<=') &&\n      (comp.operator === '>=' || comp.operator === '<=')\n    const oppositeDirectionsLessThan =\n      cmp(this.semver, '<', comp.semver, options) &&\n      (this.operator === '>=' || this.operator === '>') &&\n        (comp.operator === '<=' || comp.operator === '<')\n    const oppositeDirectionsGreaterThan =\n      cmp(this.semver, '>', comp.semver, options) &&\n      (this.operator === '<=' || this.operator === '<') &&\n        (comp.operator === '>=' || comp.operator === '>')\n\n    return (\n      sameDirectionIncreasing ||\n      sameDirectionDecreasing ||\n      (sameSemVer && differentDirectionsInclusive) ||\n      oppositeDirectionsLessThan ||\n      oppositeDirectionsGreaterThan\n    )\n  }\n}\n\nmodule.exports = Comparator\n\nconst {re, t} = require('../internal/re')\nconst cmp = require('../functions/cmp')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst Range = require('./range')\n","const Range = require('../classes/range')\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n","module.exports = __WEBPACK_EXTERNAL_MODULE__28__;","module.exports = __WEBPACK_EXTERNAL_MODULE__29__;","const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers\n}\n","const compare = require('./compare')\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n","const SemVer = require('../classes/semver')\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n","const compare = require('./compare')\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n","const compare = require('./compare')\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n","const compare = require('./compare')\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n","const SemVer = require('../classes/semver')\nconst Comparator = require('../classes/comparator')\nconst {ANY} = Comparator\nconst Range = require('../classes/range')\nconst satisfies = require('../functions/satisfies')\nconst gt = require('../functions/gt')\nconst lt = require('../functions/lt')\nconst lte = require('../functions/lte')\nconst gte = require('../functions/gte')\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n","module.exports = __WEBPACK_EXTERNAL_MODULE__37__;","module.exports = __WEBPACK_EXTERNAL_MODULE__38__;","const compare = require('./compare')\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n","const eq = require('./eq')\nconst neq = require('./neq')\nconst gt = require('./gt')\nconst gte = require('./gte')\nconst lt = require('./lt')\nconst lte = require('./lte')\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n","module.exports = __WEBPACK_EXTERNAL_MODULE__42__;","// just pre-load all the stuff that index.js lazily exports\nconst internalRe = require('./internal/re')\nmodule.exports = {\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: require('./internal/constants').SEMVER_SPEC_VERSION,\n  SemVer: require('./classes/semver'),\n  compareIdentifiers: require('./internal/identifiers').compareIdentifiers,\n  rcompareIdentifiers: require('./internal/identifiers').rcompareIdentifiers,\n  parse: require('./functions/parse'),\n  valid: require('./functions/valid'),\n  clean: require('./functions/clean'),\n  inc: require('./functions/inc'),\n  diff: require('./functions/diff'),\n  major: require('./functions/major'),\n  minor: require('./functions/minor'),\n  patch: require('./functions/patch'),\n  prerelease: require('./functions/prerelease'),\n  compare: require('./functions/compare'),\n  rcompare: require('./functions/rcompare'),\n  compareLoose: require('./functions/compare-loose'),\n  compareBuild: require('./functions/compare-build'),\n  sort: require('./functions/sort'),\n  rsort: require('./functions/rsort'),\n  gt: require('./functions/gt'),\n  lt: require('./functions/lt'),\n  eq: require('./functions/eq'),\n  neq: require('./functions/neq'),\n  gte: require('./functions/gte'),\n  lte: require('./functions/lte'),\n  cmp: require('./functions/cmp'),\n  coerce: require('./functions/coerce'),\n  Comparator: require('./classes/comparator'),\n  Range: require('./classes/range'),\n  satisfies: require('./functions/satisfies'),\n  toComparators: require('./ranges/to-comparators'),\n  maxSatisfying: require('./ranges/max-satisfying'),\n  minSatisfying: require('./ranges/min-satisfying'),\n  minVersion: require('./ranges/min-version'),\n  validRange: require('./ranges/valid'),\n  outside: require('./ranges/outside'),\n  gtr: require('./ranges/gtr'),\n  ltr: require('./ranges/ltr'),\n  intersects: require('./ranges/intersects'),\n  simplifyRange: require('./ranges/simplify'),\n  subset: require('./ranges/subset'),\n}\n","const parse = require('./parse')\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n","const parse = require('./parse')\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n","const SemVer = require('../classes/semver')\n\nconst inc = (version, release, options, identifier) => {\n  if (typeof (options) === 'string') {\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(version, options).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n","const parse = require('./parse')\nconst eq = require('./eq')\n\nconst diff = (version1, version2) => {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    const v1 = parse(version1)\n    const v2 = parse(version2)\n    const hasPre = v1.prerelease.length || v2.prerelease.length\n    const prefix = hasPre ? 'pre' : ''\n    const defaultResult = hasPre ? 'prerelease' : ''\n    for (const key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\nmodule.exports = diff\n","const SemVer = require('../classes/semver')\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n","const SemVer = require('../classes/semver')\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n","const SemVer = require('../classes/semver')\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n","const parse = require('./parse')\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n","const compare = require('./compare')\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n","const compare = require('./compare')\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n","const compareBuild = require('./compare-build')\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n","const compareBuild = require('./compare-build')\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n","const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst {re, t} = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    let next\n    while ((next = re[t.COERCERTL].exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1\n  }\n\n  if (match === null)\n    return null\n\n  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)\n}\nmodule.exports = coerce\n","const Range = require('../classes/range')\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst gt = require('../functions/gt')\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n","const Range = require('../classes/range')\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n","// Determine if version is greater than all the versions possible in the range.\nconst outside = require('./outside')\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n","const outside = require('./outside')\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n","const Range = require('../classes/range')\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\nmodule.exports = intersects\n","// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let min = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!min)\n        min = version\n    } else {\n      if (prev) {\n        set.push([min, prev])\n      }\n      prev = null\n      min = null\n    }\n  }\n  if (min)\n    set.push([min, null])\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max)\n      ranges.push(min)\n    else if (!max && min === v[0])\n      ranges.push('*')\n    else if (!max)\n      ranges.push(`>=${min}`)\n    else if (min === v[0])\n      ranges.push(`<=${max}`)\n    else\n      ranges.push(`${min} - ${max}`)\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n","const Range = require('../classes/range.js')\nconst { ANY } = require('../classes/comparator.js')\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a subset of some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else return false\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n// - If LT\n//   - If LT.semver is greater than that of any > comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n// - If any C is a = range, and GT or LT are set, return false\n// - Else return true\n\nconst subset = (sub, dom, options) => {\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub)\n        continue OUTER\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull)\n      return false\n  }\n  return true\n}\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub.length === 1 && sub[0].semver === ANY)\n    return dom.length === 1 && dom[0].semver === ANY\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=')\n      gt = higherGT(gt, c, options)\n    else if (c.operator === '<' || c.operator === '<=')\n      lt = lowerLT(lt, c, options)\n    else\n      eqSet.add(c.semver)\n  }\n\n  if (eqSet.size > 1)\n    return null\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0)\n      return null\n    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))\n      return null\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options))\n      return null\n\n    if (lt && !satisfies(eq, String(lt), options))\n      return null\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options))\n        return false\n    }\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c)\n          return false\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))\n        return false\n    }\n    if (lt) {\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c)\n          return false\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))\n        return false\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0)\n      return false\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0)\n    return false\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0)\n    return false\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n","import _ from 'lodash';\nimport * as c from './constants';\n\n/**\n * Query format migration.\n * This module can detect query format version and make migration.\n */\n\nexport function isGrafana2target(target) {\n  if (!target.mode || target.mode === 0 || target.mode === 2) {\n    if ((target.hostFilter || target.itemFilter || target.downsampleFunction ||\n        (target.host && target.host.host)) &&\n        (target.item.filter === undefined && target.host.filter === undefined)) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n\nexport function migrateFrom2To3version(target) {\n  target.group.filter = target.group.name === \"*\" ? \"/.*/\" : target.group.name;\n  target.host.filter = target.host.name === \"*\" ? convertToRegex(target.hostFilter) : target.host.name;\n  target.application.filter = target.application.name === \"*\" ? \"\" : target.application.name;\n  target.item.filter = target.item.name === \"All\" ? convertToRegex(target.itemFilter) : target.item.name;\n  return target;\n}\n\nfunction migratePercentileAgg(target) {\n  if (target.functions) {\n    for (const f of target.functions) {\n      if (f.def && f.def.name === 'percentil') {\n        f.def.name = 'percentile';\n      }\n    }\n  }\n}\n\nfunction migrateQueryType(target) {\n  if (target.queryType === undefined) {\n    if (target.mode === 'Metrics') {\n      // Explore mode\n      target.queryType = c.MODE_METRICS;\n    } else if (target.mode !== undefined) {\n      target.queryType = target.mode;\n      delete target.mode;\n    }\n  }\n}\n\nfunction migrateSLA(target) {\n  if (target.queryType === c.MODE_ITSERVICE && !target.slaInterval) {\n    target.slaInterval = 'none';\n  }\n}\n\nexport function migrate(target) {\n  target.resultFormat = target.resultFormat || 'time_series';\n  target = fixTargetGroup(target);\n  if (isGrafana2target(target)) {\n    return migrateFrom2To3version(target);\n  }\n  migratePercentileAgg(target);\n  migrateQueryType(target);\n  migrateSLA(target);\n  return target;\n}\n\nfunction fixTargetGroup(target) {\n  if (target.group && Array.isArray(target.group)) {\n    target.group = { 'filter': \"\" };\n  }\n  return target;\n}\n\nfunction convertToRegex(str) {\n  if (str) {\n    return '/' + str + '/';\n  } else {\n    return '/.*/';\n  }\n}\n\nexport const DS_CONFIG_SCHEMA = 2;\nexport function migrateDSConfig(jsonData) {\n  if (!jsonData) {\n    jsonData = {};\n  }\n\n  if (!shouldMigrateDSConfig(jsonData)) {\n    return jsonData;\n  }\n\n  const oldVersion = jsonData.schema || 1;\n  jsonData.schema = DS_CONFIG_SCHEMA;\n\n  if (oldVersion < 2) {\n    const dbConnectionOptions = jsonData.dbConnection || {};\n    jsonData.dbConnectionEnable = dbConnectionOptions.enable || false;\n    jsonData.dbConnectionDatasourceId = dbConnectionOptions.datasourceId || null;\n    delete jsonData.dbConnection;\n  }\n\n  return jsonData;\n}\n\nfunction shouldMigrateDSConfig(jsonData): boolean {\n  if (jsonData.dbConnection && !_.isEmpty(jsonData.dbConnection)) {\n    return true;\n  }\n  if (jsonData.schema && jsonData.schema !== DS_CONFIG_SCHEMA) {\n    return true;\n  }\n  return false;\n}\n","import _ from 'lodash';\nimport { isNumeric } from './utils';\n\nconst index = [];\nconst categories = {\n  Transform: [],\n  Aggregate: [],\n  Filter: [],\n  Trends: [],\n  Time: [],\n  Alias: [],\n  Special: []\n};\n\nfunction addFuncDef(funcDef) {\n  funcDef.params = funcDef.params || [];\n  funcDef.defaultParams = funcDef.defaultParams || [];\n\n  if (funcDef.category) {\n    categories[funcDef.category].push(funcDef);\n  }\n  index[funcDef.name] = funcDef;\n  index[funcDef.shortName || funcDef.name] = funcDef;\n}\n\n// Transform\n\naddFuncDef({\n  name: 'groupBy',\n  category: 'Transform',\n  params: [\n    { name: 'interval', type: 'string'},\n    { name: 'function', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: ['1m', 'avg'],\n});\n\naddFuncDef({\n  name: 'scale',\n  category: 'Transform',\n  params: [\n    { name: 'factor', type: 'float', options: [100, 0.01, 10, -1]}\n  ],\n  defaultParams: [100],\n});\n\naddFuncDef({\n  name: 'offset',\n  category: 'Transform',\n  params: [\n    { name: 'delta', type: 'float', options: [-100, 100]}\n  ],\n  defaultParams: [100],\n});\n\naddFuncDef({\n  name: 'delta',\n  category: 'Transform',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'rate',\n  category: 'Transform',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'movingAverage',\n  category: 'Transform',\n  params: [\n    { name: 'factor', type: 'int', options: [6, 10, 60, 100, 600] }\n  ],\n  defaultParams: [10],\n});\n\naddFuncDef({\n  name: 'exponentialMovingAverage',\n  category: 'Transform',\n  params: [\n    { name: 'smoothing', type: 'float', options: [6, 10, 60, 100, 600] }\n  ],\n  defaultParams: [0.2],\n});\n\naddFuncDef({\n  name: 'percentile',\n  category: 'Transform',\n  params: [\n    { name: 'interval', type: 'string' },\n    { name: 'percent', type: 'float', options: [25, 50, 75, 90, 95, 99, 99.9] }\n  ],\n  defaultParams: ['1m', 95],\n});\n\naddFuncDef({\n  name: 'removeAboveValue',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'},\n  ],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'removeBelowValue',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'},\n  ],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'transformNull',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'}\n  ],\n  defaultParams: [0],\n});\n\n// Aggregate\n\naddFuncDef({\n  name: 'sumSeries',\n  category: 'Aggregate',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'median',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string'}\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'average',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'percentileAgg',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' },\n    { name: 'percent', type: 'float', options: [25, 50, 75, 90, 95, 99, 99.9] }\n  ],\n  defaultParams: ['1m', 95],\n});\n\naddFuncDef({\n  name: 'min',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'max',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'sum',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'count',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'aggregateBy',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' },\n    { name: 'function', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: ['1m', 'avg'],\n});\n\n// Filter\n\naddFuncDef({\n  name: 'top',\n  category: 'Filter',\n  params: [\n    { name: 'number', type: 'int' },\n    { name: 'value', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: [5, 'avg'],\n});\n\naddFuncDef({\n  name: 'bottom',\n  category: 'Filter',\n  params: [\n    { name: 'number', type: 'int' },\n    { name: 'value', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: [5, 'avg'],\n});\n\naddFuncDef({\n  name: 'sortSeries',\n  category: 'Filter',\n  params: [\n    { name: 'direction', type: 'string', options: ['asc', 'desc'] }\n  ],\n  defaultParams: ['asc']\n});\n\n// Trends\n\naddFuncDef({\n  name: 'trendValue',\n  category: 'Trends',\n  params: [\n    { name: 'type', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count'] }\n  ],\n  defaultParams: ['avg'],\n});\n\n// Time\n\naddFuncDef({\n  name: 'timeShift',\n  category: 'Time',\n  params: [\n    { name: 'interval', type: 'string', options: ['24h', '7d', '1M', '+24h', '-24h']}\n  ],\n  defaultParams: ['24h'],\n});\n\n//Alias\n\naddFuncDef({\n  name: 'setAlias',\n  category: 'Alias',\n  params: [\n    { name: 'alias', type: 'string' }\n  ],\n  defaultParams: []\n});\n\naddFuncDef({\n  name: 'setAliasByRegex',\n  category: 'Alias',\n  params: [\n    { name: 'aliasByRegex', type: 'string' }\n  ],\n  defaultParams: []\n});\n\naddFuncDef({\n  name: 'replaceAlias',\n  category: 'Alias',\n  params: [\n    { name: 'regexp', type: 'string' },\n    { name: 'newAlias', type: 'string' }\n  ],\n  defaultParams: ['/(.*)/', '$1']\n});\n\n// Special\naddFuncDef({\n  name: 'consolidateBy',\n  category: 'Special',\n  params: [\n    { name: 'type', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count'] }\n  ],\n  defaultParams: ['avg'],\n});\n\n_.each(categories, (funcList, catName) => {\n  categories[catName] = _.sortBy(funcList, 'name');\n});\n\nclass FuncInstance {\n  def: any;\n  params: any;\n  text: string;\n\n  constructor(funcDef, params) {\n    this.def = funcDef;\n\n    if (params) {\n      this.params = params;\n    } else {\n      // Create with default params\n      this.params = [];\n      this.params = funcDef.defaultParams.slice(0);\n    }\n\n    this.updateText();\n  }\n\n  bindFunction(metricFunctions) {\n    const func = metricFunctions[this.def.name];\n    if (func) {\n\n      // Bind function arguments\n      let bindedFunc = func;\n      let param;\n      for (let i = 0; i < this.params.length; i++) {\n        param = this.params[i];\n\n        // Convert numeric params\n        if (this.def.params[i].type === 'int' ||\n            this.def.params[i].type === 'float') {\n          param = Number(param);\n        }\n        bindedFunc = _.partial(bindedFunc, param);\n      }\n      return bindedFunc;\n    } else {\n      throw { message: 'Method not found ' + this.def.name };\n    }\n  }\n\n  render(metricExp) {\n    const str = this.def.name + '(';\n    const parameters = _.map(this.params, (value, index) => {\n      const paramType = this.def.params[index].type;\n      if (paramType === 'int' ||\n          paramType === 'float' ||\n          paramType === 'value_or_series' ||\n          paramType === 'boolean') {\n        return value;\n      } else if (paramType === 'int_or_interval' && isNumeric(value)) {\n        return value;\n      }\n\n      return \"'\" + value + \"'\";\n\n    });\n\n    if (metricExp) {\n      parameters.unshift(metricExp);\n    }\n\n    return str + parameters.join(', ') + ')';\n  }\n\n  _hasMultipleParamsInString(strValue, index) {\n    if (strValue.indexOf(',') === -1) {\n      return false;\n    }\n\n    return this.def.params[index + 1] && this.def.params[index + 1].optional;\n  }\n\n  updateParam(strValue, index) {\n    // handle optional parameters\n    // if string contains ',' and next param is optional, split and update both\n    if (this._hasMultipleParamsInString(strValue, index)) {\n      _.each(strValue.split(','), (partVal, idx) => {\n        this.updateParam(partVal.trim(), idx);\n      });\n      return;\n    }\n\n    if (strValue === '' && this.def.params[index].optional) {\n      this.params.splice(index, 1);\n    }else {\n      this.params[index] = strValue;\n    }\n\n    this.updateText();\n  }\n\n  updateText() {\n    if (this.params.length === 0) {\n      this.text = this.def.name + '()';\n      return;\n    }\n\n    let text = this.def.name + '(';\n    text += this.params.join(', ');\n    text += ')';\n    this.text = text;\n  }\n}\n\nexport function createFuncInstance(funcDef, params) {\n  if (_.isString(funcDef)) {\n    if (!index[funcDef]) {\n      throw { message: 'Method not found ' + name };\n    }\n    funcDef = index[funcDef];\n  }\n  return new FuncInstance(funcDef, params);\n}\n\nexport function getFuncDef(name) {\n  return index[name];\n}\n\nexport function getCategories() {\n  return categories;\n}\n","/**\n * timeseries.js\n *\n * This module contains functions for working with time series.\n *\n * datapoints - array of points where point is [value, timestamp]. In almost all cases (if other wasn't\n * explicitly said) we assume datapoints are sorted by timestamp. Timestamp is the number of milliseconds\n * since 1 January 1970 00:00:00 UTC.\n *\n */\n\nimport _ from 'lodash';\nimport * as utils from './utils';\nimport * as c from './constants';\n\nconst POINT_VALUE = 0;\nconst POINT_TIMESTAMP = 1;\n\n/**\n * Downsample time series by using given function (avg, min, max).\n */\nfunction downsample(datapoints, time_to, ms_interval, func) {\n  const downsampledSeries = [];\n  const timeWindow = {\n    from: time_to * 1000 - ms_interval,\n    to: time_to * 1000\n  };\n\n  let points_sum = 0;\n  let points_num = 0;\n  let value_avg = 0;\n  let frame = [];\n\n  for (let i = datapoints.length - 1; i >= 0; i -= 1) {\n    if (timeWindow.from < datapoints[i][1] && datapoints[i][1] <= timeWindow.to) {\n      points_sum += datapoints[i][0];\n      points_num++;\n      frame.push(datapoints[i][0]);\n    } else {\n      value_avg = points_num ? points_sum / points_num : 0;\n\n      if (func === \"max\") {\n        downsampledSeries.push([_.max(frame), timeWindow.to]);\n      } else if (func === \"min\") {\n        downsampledSeries.push([_.min(frame), timeWindow.to]);\n      } else {\n        downsampledSeries.push([value_avg, timeWindow.to]);\n      }\n\n      // Shift time window\n      timeWindow.to = timeWindow.from;\n      timeWindow.from -= ms_interval;\n\n      points_sum = 0;\n      points_num = 0;\n      frame = [];\n\n      // Process point again\n      i++;\n    }\n  }\n  return downsampledSeries.reverse();\n}\n\n/**\n * Group points by given time interval\n * datapoints: [[<value>, <unixtime>], ...]\n */\nfunction groupBy(datapoints, interval, groupByCallback) {\n  const ms_interval = utils.parseInterval(interval);\n\n  // Calculate frame timestamps\n  const frames = _.groupBy(datapoints, point => {\n    // Calculate time for group of points\n    return Math.floor(point[1] / ms_interval) * ms_interval;\n  });\n\n  // frame: { '<unixtime>': [[<value>, <unixtime>], ...] }\n  // return [{ '<unixtime>': <value> }, { '<unixtime>': <value> }, ...]\n  const grouped = _.mapValues(frames, frame => {\n    const points = _.map(frame, point => {\n      return point[0];\n    });\n    return groupByCallback(points);\n  });\n\n  // Convert points to Grafana format\n  return sortByTime(_.map(grouped, (value, timestamp) => {\n    return [Number(value), Number(timestamp)];\n  }));\n}\n\nexport function groupBy_perf(datapoints, interval, groupByCallback) {\n  if (datapoints.length === 0) {\n    return [];\n  }\n\n  if (interval === c.RANGE_VARIABLE_VALUE) {\n    return groupByRange(datapoints, groupByCallback);\n  }\n\n  const ms_interval = utils.parseInterval(interval);\n  const grouped_series = [];\n  let frame_values = [];\n  let frame_value;\n  let frame_ts = datapoints.length ? getPointTimeFrame(datapoints[0][POINT_TIMESTAMP], ms_interval) : 0;\n  let point_frame_ts = frame_ts;\n  let point;\n\n  for (let i = 0; i < datapoints.length; i++) {\n    point = datapoints[i];\n    point_frame_ts = getPointTimeFrame(point[POINT_TIMESTAMP], ms_interval);\n    if (point_frame_ts === frame_ts) {\n      frame_values.push(point[POINT_VALUE]);\n    } else if (point_frame_ts > frame_ts) {\n      frame_value = groupByCallback(frame_values);\n      grouped_series.push([frame_value, frame_ts]);\n\n      // Move frame window to next non-empty interval and fill empty by null\n      frame_ts += ms_interval;\n      while (frame_ts < point_frame_ts) {\n        grouped_series.push([null, frame_ts]);\n        frame_ts += ms_interval;\n      }\n      frame_values = [point[POINT_VALUE]];\n    }\n  }\n\n  frame_value = groupByCallback(frame_values);\n  grouped_series.push([frame_value, frame_ts]);\n\n  return grouped_series;\n}\n\nexport function groupByRange(datapoints, groupByCallback) {\n  const frame_values = [];\n  const frame_start = datapoints[0][POINT_TIMESTAMP];\n  const frame_end = datapoints[datapoints.length - 1][POINT_TIMESTAMP];\n  let point;\n  for (let i = 0; i < datapoints.length; i++) {\n    point = datapoints[i];\n    frame_values.push(point[POINT_VALUE]);\n  }\n  const frame_value = groupByCallback(frame_values);\n  return [[frame_value, frame_start], [frame_value, frame_end]];\n}\n\n/**\n * Summarize set of time series into one.\n * @param {datapoints[]} timeseries array of time series\n */\nfunction sumSeries(timeseries) {\n\n  // Calculate new points for interpolation\n  let new_timestamps = _.uniq(_.map(_.flatten(timeseries), point => {\n    return point[1];\n  }));\n  new_timestamps = _.sortBy(new_timestamps);\n\n  const interpolated_timeseries = _.map(timeseries, series => {\n    series = fillZeroes(series, new_timestamps);\n    const timestamps = _.map(series, point => {\n      return point[1];\n    });\n    const new_points = _.map(_.difference(new_timestamps, timestamps), timestamp => {\n      return [null, timestamp];\n    });\n    const new_series = series.concat(new_points);\n    return sortByTime(new_series);\n  });\n\n  _.each(interpolated_timeseries, interpolateSeries);\n\n  const new_timeseries = [];\n  let sum;\n  for (let i = new_timestamps.length - 1; i >= 0; i--) {\n    sum = 0;\n    for (let j = interpolated_timeseries.length - 1; j >= 0; j--) {\n      sum += interpolated_timeseries[j][i][0];\n    }\n    new_timeseries.push([sum, new_timestamps[i]]);\n  }\n\n  return sortByTime(new_timeseries);\n}\n\nfunction scale(datapoints, factor) {\n  return _.map(datapoints, point => {\n    return [\n      point[0] * factor,\n      point[1]\n    ];\n  });\n}\n\nfunction scale_perf(datapoints, factor) {\n  for (let i = 0; i < datapoints.length; i++) {\n    datapoints[i] = [\n      datapoints[i][POINT_VALUE] * factor,\n      datapoints[i][POINT_TIMESTAMP]\n    ];\n  }\n\n  return datapoints;\n}\n\nfunction offset(datapoints, delta) {\n  for (let i = 0; i < datapoints.length; i++) {\n    datapoints[i] = [\n      datapoints[i][POINT_VALUE] + delta,\n      datapoints[i][POINT_TIMESTAMP]\n    ];\n  }\n\n  return datapoints;\n}\n\n/**\n * Simple delta. Calculate value delta between points.\n * @param {*} datapoints\n */\nfunction delta(datapoints) {\n  const newSeries = [];\n  let deltaValue;\n  for (let i = 1; i < datapoints.length; i++) {\n    deltaValue = datapoints[i][0] - datapoints[i - 1][0];\n    newSeries.push([deltaValue, datapoints[i][1]]);\n  }\n  return newSeries;\n}\n\n/**\n * Calculates rate per second. Resistant to counter reset.\n * @param {*} datapoints\n */\nfunction rate(datapoints) {\n  const newSeries = [];\n  let point, point_prev;\n  let valueDelta = 0;\n  let timeDelta = 0;\n  for (let i = 1; i < datapoints.length; i++) {\n    point = datapoints[i];\n    point_prev = datapoints[i - 1];\n\n    // Convert ms to seconds\n    timeDelta = (point[POINT_TIMESTAMP] - point_prev[POINT_TIMESTAMP]) / 1000;\n\n    // Handle counter reset - use previous value\n    if (point[POINT_VALUE] >= point_prev[POINT_VALUE]) {\n      valueDelta = (point[POINT_VALUE] - point_prev[POINT_VALUE]) / timeDelta;\n    }\n\n    newSeries.push([valueDelta, point[POINT_TIMESTAMP]]);\n  }\n  return newSeries;\n}\n\nfunction simpleMovingAverage(datapoints, n) {\n  const sma = [];\n  let w_sum;\n  let w_avg = null;\n  let w_count = 0;\n\n  // Initial window\n  for (let j = n; j > 0; j--) {\n    if (datapoints[n - j][POINT_VALUE] !== null) {\n      w_avg += datapoints[n - j][POINT_VALUE];\n      w_count++;\n    }\n  }\n  if (w_count > 0) {\n    w_avg = w_avg / w_count;\n  } else {\n    w_avg = null;\n  }\n  sma.push([w_avg, datapoints[n - 1][POINT_TIMESTAMP]]);\n\n  for (let i = n; i < datapoints.length; i++) {\n    // Insert next value\n    if (datapoints[i][POINT_VALUE] !== null) {\n      w_sum = w_avg * w_count;\n      w_avg = (w_sum + datapoints[i][POINT_VALUE]) / (w_count + 1);\n      w_count++;\n    }\n    // Remove left side point\n    if (datapoints[i - n][POINT_VALUE] !== null) {\n      w_sum = w_avg * w_count;\n      if (w_count > 1) {\n        w_avg = (w_sum - datapoints[i - n][POINT_VALUE]) / (w_count - 1);\n        w_count--;\n      } else {\n        w_avg = null;\n        w_count = 0;\n      }\n    }\n    sma.push([w_avg, datapoints[i][POINT_TIMESTAMP]]);\n  }\n  return sma;\n}\n\nfunction expMovingAverage(datapoints, n) {\n  let ema = [datapoints[0]];\n  let ema_prev = datapoints[0][POINT_VALUE];\n  let ema_cur;\n  let a;\n\n  if (n > 1) {\n    // Calculate a from window size\n    a = 2 / (n + 1);\n\n    // Initial window, use simple moving average\n    let w_avg = null;\n    let w_count = 0;\n    for (let j = n; j > 0; j--) {\n      if (datapoints[n - j][POINT_VALUE] !== null) {\n        w_avg += datapoints[n - j][POINT_VALUE];\n        w_count++;\n      }\n    }\n    if (w_count > 0) {\n      w_avg = w_avg / w_count;\n      // Actually, we should set timestamp from datapoints[n-1] and start calculation of EMA from n.\n      // But in order to start EMA from first point (not from Nth) we should expand time range and request N additional\n      // points outside left side of range. We can't do that, so this trick is used for pretty view of first N points.\n      // We calculate AVG for first N points, but then start from 2nd point, not from Nth. In general, it means we\n      // assume that previous N values (0-N, 0-(N-1), ..., 0-1) have the same average value as a first N values.\n      ema = [[w_avg, datapoints[0][POINT_TIMESTAMP]]];\n      ema_prev = w_avg;\n      n = 1;\n    }\n  } else {\n    // Use predefined a and start from 1st point (use it as initial EMA value)\n    a = n;\n    n = 1;\n  }\n\n  for (let i = n; i < datapoints.length; i++) {\n    if (datapoints[i][POINT_VALUE] !== null) {\n      ema_cur = a * datapoints[i][POINT_VALUE] + (1 - a) * ema_prev;\n      ema_prev = ema_cur;\n      ema.push([ema_cur, datapoints[i][POINT_TIMESTAMP]]);\n    } else {\n      ema.push([null, datapoints[i][POINT_TIMESTAMP]]);\n    }\n  }\n  return ema;\n}\n\nfunction PERCENTILE(n, values) {\n  const sorted = _.sortBy(values);\n  return sorted[Math.floor(sorted.length * n / 100)];\n}\n\nfunction COUNT(values) {\n  return values.length;\n}\n\nfunction SUM(values) {\n  let sum = null;\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      sum += values[i];\n    }\n  }\n  return sum;\n}\n\nfunction AVERAGE(values) {\n  const values_non_null = getNonNullValues(values);\n  if (values_non_null.length === 0) {\n    return null;\n  }\n  return SUM(values_non_null) / values_non_null.length;\n}\n\nfunction getNonNullValues(values) {\n  const values_non_null = [];\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      values_non_null.push(values[i]);\n    }\n  }\n  return values_non_null;\n}\n\nfunction MIN(values) {\n  return _.min(values);\n}\n\nfunction MAX(values) {\n  return _.max(values);\n}\n\nfunction MEDIAN(values) {\n  const sorted = _.sortBy(values);\n  return sorted[Math.floor(sorted.length / 2)];\n}\n\n///////////////////////\n// Utility functions //\n///////////////////////\n\n/**\n * For given point calculate corresponding time frame.\n *\n * |__*_|_*__|___*| -> |*___|*___|*___|\n *\n * @param {*} timestamp\n * @param {*} ms_interval\n */\nfunction getPointTimeFrame(timestamp, ms_interval) {\n  return Math.floor(timestamp / ms_interval) * ms_interval;\n}\n\nfunction sortByTime(series) {\n  return _.sortBy(series, point => {\n    return point[1];\n  });\n}\n\n/**\n * Fill empty front and end of series by zeroes.\n *\n * |   ***   |    |   ***   |\n * |___   ___| -> |***   ***|\n * @param {*} series\n * @param {*} timestamps\n */\nfunction fillZeroes(series, timestamps) {\n  const prepend = [];\n  const append = [];\n  let new_point;\n  for (let i = 0; i < timestamps.length; i++) {\n    if (timestamps[i] < series[0][POINT_TIMESTAMP]) {\n      new_point = [0, timestamps[i]];\n      prepend.push(new_point);\n    } else if (timestamps[i] > series[series.length - 1][POINT_TIMESTAMP]) {\n      new_point = [0, timestamps[i]];\n      append.push(new_point);\n    }\n  }\n  return _.concat(_.concat(prepend, series), append);\n}\n\n/**\n * Interpolate series with gaps\n */\nfunction interpolateSeries(series) {\n  let left, right;\n\n  // Interpolate series\n  for (let i = series.length - 1; i >= 0; i--) {\n    if (!series[i][0]) {\n      left = findNearestLeft(series, i);\n      right = findNearestRight(series, i);\n      if (!left) {\n        left = right;\n      }\n      if (!right) {\n        right = left;\n      }\n      series[i][0] = linearInterpolation(series[i][1], left, right);\n    }\n  }\n  return series;\n}\n\nfunction linearInterpolation(timestamp, left, right) {\n  if (left[1] === right[1]) {\n    return (left[0] + right[0]) / 2;\n  } else {\n    return (left[0] + (right[0] - left[0]) / (right[1] - left[1]) * (timestamp - left[1]));\n  }\n}\n\nfunction findNearestRight(series, pointIndex) {\n  for (let i = pointIndex; i < series.length; i++) {\n    if (series[i][0] !== null) {\n      return series[i];\n    }\n  }\n  return null;\n}\n\nfunction findNearestLeft(series, pointIndex) {\n  for (let i = pointIndex; i > 0; i--) {\n    if (series[i][0] !== null) {\n      return series[i];\n    }\n  }\n  return null;\n}\n\nfunction flattenDatapoints(datapoints) {\n  const depth = utils.getArrayDepth(datapoints);\n  if (depth <= 2) {\n    // Don't process if datapoints already flattened\n    return datapoints;\n  }\n  return _.flatten(datapoints);\n}\n\n////////////\n// Export //\n////////////\n\nconst exportedFunctions = {\n  downsample,\n  groupBy,\n  groupBy_perf,\n  groupByRange,\n  sumSeries,\n  scale,\n  offset,\n  scale_perf,\n  delta,\n  rate,\n  simpleMovingAverage,\n  expMovingAverage,\n  SUM,\n  COUNT,\n  AVERAGE,\n  MIN,\n  MAX,\n  MEDIAN,\n  PERCENTILE,\n  sortByTime,\n  flattenDatapoints,\n};\n\nexport default exportedFunctions;\n","import _ from 'lodash';\n// Available in 7.0\n// import { getTemplateSrv } from '@grafana/runtime';\nimport * as utils from './utils';\nimport ts, { groupBy_perf as groupBy } from './timeseries';\n\nconst SUM = ts.SUM;\nconst COUNT = ts.COUNT;\nconst AVERAGE = ts.AVERAGE;\nconst MIN = ts.MIN;\nconst MAX = ts.MAX;\nconst MEDIAN = ts.MEDIAN;\nconst PERCENTILE = ts.PERCENTILE;\n\nconst downsampleSeries = ts.downsample;\nconst groupBy_exported = (interval, groupFunc, datapoints) => groupBy(datapoints, interval, groupFunc);\nconst sumSeries = ts.sumSeries;\nconst delta = ts.delta;\nconst rate = ts.rate;\nconst scale = (factor, datapoints) => ts.scale_perf(datapoints, factor);\nconst offset = (delta, datapoints) => ts.offset(datapoints, delta);\nconst simpleMovingAverage = (n, datapoints) => ts.simpleMovingAverage(datapoints, n);\nconst expMovingAverage = (a, datapoints) => ts.expMovingAverage(datapoints, a);\nconst percentile = (interval, n, datapoints) => groupBy(datapoints, interval, _.partial(PERCENTILE, n));\n\nfunction limit(order, n, orderByFunc, timeseries) {\n  const orderByCallback = aggregationFunctions[orderByFunc];\n  const sortByIteratee = (ts) => {\n    const values = _.map(ts.datapoints, (point) => {\n      return point[0];\n    });\n    return orderByCallback(values);\n  };\n  const sortedTimeseries = _.sortBy(timeseries, sortByIteratee);\n  if (order === 'bottom') {\n    return sortedTimeseries.slice(0, n);\n  } else {\n    return sortedTimeseries.slice(-n);\n  }\n}\n\nfunction removeAboveValue(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] > n) ? null : point[0],\n      point[1]\n    ];\n  });\n}\n\nfunction removeBelowValue(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] < n) ? null : point[0],\n      point[1]\n    ];\n  });\n}\n\nfunction transformNull(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] !== null) ? point[0] : n,\n      point[1]\n    ];\n  });\n}\n\nfunction sortSeries(direction, timeseries: any[]) {\n  return _.orderBy(timeseries, [ts => {\n    return ts.target.toLowerCase();\n  }], direction);\n}\n\nfunction setAlias(alias, timeseries) {\n  // TODO: use getTemplateSrv() when available (since 7.0)\n  if (this.templateSrv && timeseries && timeseries.scopedVars) {\n    alias = this.templateSrv.replace(alias, timeseries.scopedVars);\n  }\n  timeseries.target = alias;\n  return timeseries;\n}\n\nfunction replaceAlias(regexp, newAlias, timeseries) {\n  let pattern;\n  if (utils.isRegex(regexp)) {\n    pattern = utils.buildRegex(regexp);\n  } else {\n    pattern = regexp;\n  }\n\n  let alias = timeseries.target.replace(pattern, newAlias);\n  // TODO: use getTemplateSrv() when available (since 7.0)\n  if (this.templateSrv && timeseries && timeseries.scopedVars) {\n    alias = this.templateSrv.replace(alias, timeseries.scopedVars);\n  }\n  timeseries.target = alias;\n  return timeseries;\n}\n\nfunction setAliasByRegex(alias, timeseries) {\n  timeseries.target = extractText(timeseries.target, alias);\n  return timeseries;\n}\n\nfunction extractText(str, pattern) {\n  const extractPattern = new RegExp(pattern);\n  const extractedValue = extractPattern.exec(str);\n  return extractedValue[0];\n}\n\nfunction groupByWrapper(interval, groupFunc, datapoints) {\n  const groupByCallback = aggregationFunctions[groupFunc];\n  return groupBy(datapoints, interval, groupByCallback);\n}\n\nfunction aggregateByWrapper(interval, aggregateFunc, datapoints) {\n  // Flatten all points in frame and then just use groupBy()\n  const flattenedPoints = ts.flattenDatapoints(datapoints);\n  // groupBy_perf works with sorted series only\n  const sortedPoints = ts.sortByTime(flattenedPoints);\n  const groupByCallback = aggregationFunctions[aggregateFunc];\n  return groupBy(sortedPoints, interval, groupByCallback);\n}\n\nfunction aggregateWrapper(groupByCallback, interval, datapoints) {\n  const flattenedPoints = ts.flattenDatapoints(datapoints);\n  // groupBy_perf works with sorted series only\n  const sortedPoints = ts.sortByTime(flattenedPoints);\n  return groupBy(sortedPoints, interval, groupByCallback);\n}\n\nfunction percentileAgg(interval, n, datapoints) {\n  const flattenedPoints = ts.flattenDatapoints(datapoints);\n  // groupBy_perf works with sorted series only\n  const sortedPoints = ts.sortByTime(flattenedPoints);\n  const groupByCallback = _.partial(PERCENTILE, n);\n  return groupBy(sortedPoints, interval, groupByCallback);\n}\n\nfunction timeShift(interval, range) {\n  const shift = utils.parseTimeShiftInterval(interval) / 1000;\n  return _.map(range, time => {\n    return time - shift;\n  });\n}\n\nfunction unShiftTimeSeries(interval, datapoints) {\n  const unshift = utils.parseTimeShiftInterval(interval);\n  return _.map(datapoints, dp => {\n    return [\n      dp[0],\n      dp[1] + unshift\n    ];\n  });\n}\n\nconst metricFunctions = {\n  groupBy: groupByWrapper,\n  scale: scale,\n  offset: offset,\n  delta: delta,\n  rate: rate,\n  movingAverage: simpleMovingAverage,\n  exponentialMovingAverage: expMovingAverage,\n  percentile: percentile,\n  transformNull: transformNull,\n  aggregateBy: aggregateByWrapper,\n  // Predefined aggs\n  percentileAgg: percentileAgg,\n  average: _.partial(aggregateWrapper, AVERAGE),\n  min: _.partial(aggregateWrapper, MIN),\n  max: _.partial(aggregateWrapper, MAX),\n  median: _.partial(aggregateWrapper, MEDIAN),\n  sum: _.partial(aggregateWrapper, SUM),\n  count: _.partial(aggregateWrapper, COUNT),\n  sumSeries: sumSeries,\n  removeAboveValue: removeAboveValue,\n  removeBelowValue: removeBelowValue,\n  top: _.partial(limit, 'top'),\n  bottom: _.partial(limit, 'bottom'),\n  sortSeries: sortSeries,\n  timeShift: timeShift,\n  setAlias: setAlias,\n  setAliasByRegex: setAliasByRegex,\n  replaceAlias: replaceAlias\n};\n\nconst aggregationFunctions = {\n  avg: AVERAGE,\n  min: MIN,\n  max: MAX,\n  median: MEDIAN,\n  sum: SUM,\n  count: COUNT\n};\n\nexport default {\n  downsampleSeries: downsampleSeries,\n  groupBy: groupBy_exported,\n  AVERAGE: AVERAGE,\n  MIN: MIN,\n  MAX: MAX,\n  MEDIAN: MEDIAN,\n  SUM: SUM,\n  COUNT: COUNT,\n  unShiftTimeSeries: unShiftTimeSeries,\n\n  get aggregationFunctions() {\n    return aggregationFunctions;\n  },\n\n  get metricFunctions() {\n    return metricFunctions;\n  }\n};\n","import _ from 'lodash';\nimport TableModel from 'grafana/app/core/table_model';\nimport * as c from './constants';\n\n/**\n * Convert Zabbix API history.get response to Grafana format\n *\n * @return {Array}            Array of timeseries in Grafana format\n *                            {\n *                               target: \"Metric name\",\n *                               datapoints: [[<value>, <unixtime>], ...]\n *                            }\n */\nfunction convertHistory(history, items, addHostName, convertPointCallback) {\n  /**\n   * Response should be in the format:\n   * data: [\n   *          {\n   *             target: \"Metric name\",\n   *             datapoints: [[<value>, <unixtime>], ...]\n   *          }, ...\n   *       ]\n   */\n\n  // Group history by itemid\n  const grouped_history = _.groupBy(history, 'itemid');\n  const hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid');  //uniqBy is needed to deduplicate\n\n  return _.map(grouped_history, (hist, itemid) => {\n    const item = _.find(items, {'itemid': itemid}) as any;\n    let alias = item.name;\n\n    // Add scopedVars for using in alias functions\n    const scopedVars: any = {\n      '__zbx_item': { value: item.name },\n      '__zbx_item_name': { value: item.name },\n      '__zbx_item_key': { value: item.key_ },\n    };\n\n    if (_.keys(hosts).length > 0) {\n      const host = _.find(hosts, {'hostid': item.hostid});\n      scopedVars['__zbx_host'] = { value: host.host };\n      scopedVars['__zbx_host_name'] = { value: host.name };\n\n      // Only add host when multiple hosts selected\n      if (_.keys(hosts).length > 1 && addHostName) {\n        alias = host.name + \": \" + alias;\n      }\n    }\n\n    return {\n      target: alias,\n      datapoints: _.map(hist, convertPointCallback),\n      scopedVars,\n    };\n  });\n}\n\nfunction sortTimeseries(timeseries) {\n  // Sort trend data, issue #202\n  _.forEach(timeseries, series => {\n    series.datapoints = _.sortBy(series.datapoints, point => point[c.DATAPOINT_TS]);\n  });\n  return timeseries;\n}\n\nfunction handleHistory(history, items, addHostName = true) {\n  return convertHistory(history, items, addHostName, convertHistoryPoint);\n}\n\nfunction handleTrends(history, items, valueType, addHostName = true) {\n  const convertPointCallback = _.partial(convertTrendPoint, valueType);\n  return convertHistory(history, items, addHostName, convertPointCallback);\n}\n\nfunction handleText(history, items, target, addHostName = true) {\n  const convertTextCallback = _.partial(convertText, target);\n  return convertHistory(history, items, addHostName, convertTextCallback);\n}\n\nfunction handleHistoryAsTable(history, items, target) {\n  const table: any = new TableModel();\n  table.addColumn({text: 'Host'});\n  table.addColumn({text: 'Item'});\n  table.addColumn({text: 'Key'});\n  table.addColumn({text: 'Last value'});\n\n  const grouped_history = _.groupBy(history, 'itemid');\n  _.each(items, (item) => {\n    const itemHistory = grouped_history[item.itemid] || [];\n    const lastPoint = _.last(itemHistory);\n    let lastValue = lastPoint ? lastPoint.value : null;\n\n    if (target.options.skipEmptyValues && (!lastValue || lastValue === '')) {\n      return;\n    }\n\n    // Regex-based extractor\n    if (target.textFilter) {\n      lastValue = extractText(lastValue, target.textFilter, target.useCaptureGroups);\n    }\n\n    let host: any = _.first(item.hosts);\n    host = host ? host.name : \"\";\n\n    table.rows.push([\n      host, item.name, item.key_, lastValue\n    ]);\n  });\n\n  return table;\n}\n\nfunction convertText(target, point) {\n  let value = point.value;\n\n  // Regex-based extractor\n  if (target.textFilter) {\n    value = extractText(point.value, target.textFilter, target.useCaptureGroups);\n  }\n\n  return [\n    value,\n    point.clock * 1000 + Math.round(point.ns / 1000000)\n  ];\n}\n\nfunction extractText(str, pattern, useCaptureGroups) {\n  const extractPattern = new RegExp(pattern);\n  const extractedValue = extractPattern.exec(str);\n  if (extractedValue) {\n    if (useCaptureGroups) {\n      return extractedValue[1];\n    } else {\n      return extractedValue[0];\n    }\n  }\n  return \"\";\n}\n\nfunction handleSLAResponse(itservice, slaProperty, slaObject) {\n  const targetSLA = slaObject[itservice.serviceid].sla;\n  if (slaProperty.property === 'status') {\n    const targetStatus = parseInt(slaObject[itservice.serviceid].status, 10);\n    return {\n      target: itservice.name + ' ' + slaProperty.name,\n      datapoints: [\n        [targetStatus, targetSLA[0].to * 1000]\n      ]\n    };\n  } else {\n    let i;\n    const slaArr = [];\n    for (i = 0; i < targetSLA.length; i++) {\n      if (i === 0) {\n        slaArr.push([targetSLA[i][slaProperty.property], targetSLA[i].from * 1000]);\n      }\n      slaArr.push([targetSLA[i][slaProperty.property], targetSLA[i].to * 1000]);\n    }\n    return {\n      target: itservice.name + ' ' + slaProperty.name,\n      datapoints: slaArr\n    };\n  }\n}\n\nfunction handleTriggersResponse(triggers, groups, timeRange) {\n  if (!_.isArray(triggers)) {\n    let triggersCount = null;\n    try {\n      triggersCount = Number(triggers);\n    } catch (err) {\n      console.log(\"Error when handling triggers count: \", err);\n    }\n    return {\n      target: \"triggers count\",\n      datapoints: [\n        [triggersCount, timeRange[1] * 1000]\n      ]\n    };\n  } else {\n    const stats = getTriggerStats(triggers);\n    const groupNames = _.map(groups, 'name');\n    const table: any = new TableModel();\n    table.addColumn({text: 'Host group'});\n    _.each(_.orderBy(c.TRIGGER_SEVERITY, ['val'], ['desc']), (severity) => {\n      table.addColumn({text: severity.text});\n    });\n    _.each(stats, (severity_stats, group) => {\n      if (_.includes(groupNames, group)) {\n        let row = _.map(_.orderBy(_.toPairs(severity_stats), (s) => s[0], ['desc']), (s) => s[1]);\n        row = _.concat([group], ...row);\n        table.rows.push(row);\n      }\n    });\n    return table;\n  }\n}\n\nfunction getTriggerStats(triggers) {\n  const groups = _.uniq(_.flattenDeep(_.map(triggers, (trigger) => _.map(trigger.groups, 'name'))));\n  // let severity = _.map(c.TRIGGER_SEVERITY, 'text');\n  const stats = {};\n  _.each(groups, (group) => {\n    stats[group] = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0}; // severity:count\n  });\n  _.each(triggers, (trigger) => {\n    _.each(trigger.groups, (group) => {\n      stats[group.name][trigger.priority]++;\n    });\n  });\n  return stats;\n}\n\nfunction convertHistoryPoint(point) {\n  // Value must be a number for properly work\n  return [\n    Number(point.value),\n    point.clock * 1000 + Math.round(point.ns / 1000000)\n  ];\n}\n\nfunction convertTrendPoint(valueType, point) {\n  let value;\n  switch (valueType) {\n    case \"min\":\n      value = point.value_min;\n      break;\n    case \"max\":\n      value = point.value_max;\n      break;\n    case \"avg\":\n      value = point.value_avg;\n      break;\n    case \"sum\":\n      value = point.value_sum;\n      break;\n    case \"count\":\n      value = point.value_count;\n      break;\n    default:\n      value = point.value_avg;\n  }\n\n  return [\n    Number(value),\n    point.clock * 1000\n  ];\n}\n\nexport default {\n  handleHistory,\n  convertHistory,\n  handleTrends,\n  handleText,\n  handleHistoryAsTable,\n  handleSLAResponse,\n  handleTriggersResponse,\n  sortTimeseries\n};\n","import _ from 'lodash';\nimport * as utils from '../datasource-zabbix/utils';\nimport { DataFrame, Field, FieldType, ArrayVector } from '@grafana/data';\nimport { ZBXProblem, ZBXTrigger, ProblemDTO, ZBXEvent } from './types';\n\nexport function joinTriggersWithProblems(problems: ZBXProblem[], triggers: ZBXTrigger[]): ProblemDTO[] {\n  const problemDTOList: ProblemDTO[] = [];\n\n  for (let i = 0; i < problems.length; i++) {\n    const p = problems[i];\n    const triggerId = Number(p.objectid);\n    const t = triggers[triggerId];\n\n    if (t) {\n      const problemDTO: ProblemDTO = {\n        timestamp: Number(p.clock),\n        triggerid: p.objectid,\n        eventid: p.eventid,\n        name: p.name,\n        severity: p.severity,\n        acknowledged: p.acknowledged,\n        acknowledges: p.acknowledges,\n        tags: p.tags,\n        suppressed: p.suppressed,\n        suppression_data: p.suppression_data,\n        description: t.description,\n        comments: t.comments,\n        value: t.value,\n        groups: t.groups,\n        hosts: t.hosts,\n        items: t.items,\n        alerts: t.alerts,\n        url: t.url,\n        expression: t.expression,\n        correlation_mode: t.correlation_mode,\n        correlation_tag: t.correlation_tag,\n        manual_close: t.manual_close,\n        state: t.state,\n        error: t.error,\n      };\n\n      problemDTOList.push(problemDTO);\n    }\n\n  }\n\n  return problemDTOList;\n}\n\ninterface JoinOptions {\n  valueFromEvent?: boolean;\n}\n\nexport function joinTriggersWithEvents(events: ZBXEvent[], triggers: ZBXTrigger[], options?: JoinOptions): ProblemDTO[] {\n  const { valueFromEvent } = options;\n  const problemDTOList: ProblemDTO[] = [];\n\n  for (let i = 0; i < events.length; i++) {\n    const e = events[i];\n    const triggerId = Number(e.objectid);\n    const t = triggers[triggerId];\n\n    if (t) {\n      const problemDTO: ProblemDTO = {\n        value: valueFromEvent ? e.value : t.value,\n        timestamp: Number(e.clock),\n        triggerid: e.objectid,\n        eventid: e.eventid,\n        name: e.name,\n        severity: e.severity,\n        acknowledged: e.acknowledged,\n        acknowledges: e.acknowledges,\n        tags: e.tags,\n        suppressed: e.suppressed,\n        description: t.description,\n        comments: t.comments,\n        groups: t.groups,\n        hosts: t.hosts,\n        items: t.items,\n        alerts: t.alerts,\n        url: t.url,\n        expression: t.expression,\n        correlation_mode: t.correlation_mode,\n        correlation_tag: t.correlation_tag,\n        manual_close: t.manual_close,\n        state: t.state,\n        error: t.error,\n      };\n\n      problemDTOList.push(problemDTO);\n    }\n\n  }\n\n  return problemDTOList;\n}\n\nexport function setMaintenanceStatus(triggers) {\n  _.each(triggers, (trigger) => {\n    const maintenance_status = _.some(trigger.hosts, (host) => host.maintenance_status === '1');\n    trigger.maintenance = maintenance_status;\n  });\n  return triggers;\n}\n\nexport function setAckButtonStatus(triggers, showAckButton) {\n  _.each(triggers, (trigger) => {\n    trigger.showAckButton = showAckButton;\n  });\n  return triggers;\n}\n\nexport function addTriggerDataSource(triggers, target) {\n  _.each(triggers, (trigger) => {\n    trigger.datasource = target.datasource;\n  });\n  return triggers;\n}\n\nexport function addTriggerHostProxy(triggers, proxies) {\n  triggers.forEach(trigger => {\n    if (trigger.hosts && trigger.hosts.length) {\n      const host = trigger.hosts[0];\n      if (host.proxy_hostid !== '0') {\n        const hostProxy = proxies[host.proxy_hostid];\n        host.proxy = hostProxy ? hostProxy.host : '';\n      }\n    }\n  });\n  return triggers;\n}\n\nexport function filterTriggersPre(triggerList, replacedTarget) {\n  // Filter triggers by description\n  const triggerFilter = replacedTarget.trigger.filter;\n  if (triggerFilter) {\n    triggerList = filterTriggers(triggerList, triggerFilter);\n  }\n\n  // Filter by tags\n  if (replacedTarget.tags.filter) {\n    let tagsFilter = replacedTarget.tags.filter;\n    // replaceTemplateVars() builds regex-like string, so we should trim it.\n    tagsFilter = tagsFilter.replace('/^', '').replace('$/', '');\n    const tags = utils.parseTags(tagsFilter);\n    triggerList = _.filter(triggerList, trigger => {\n      return _.every(tags, tag => {\n        return _.find(trigger.tags, t => t.tag === tag.tag && (!tag.value || t.value === tag.value));\n      });\n    });\n  }\n\n  // Filter by maintenance status\n  if (!replacedTarget.options.hostsInMaintenance) {\n    triggerList = _.filter(triggerList, (trigger) => !trigger.maintenance);\n  }\n\n  return triggerList;\n}\n\nfunction filterTriggers(triggers, triggerFilter) {\n  if (utils.isRegex(triggerFilter)) {\n    return _.filter(triggers, trigger => {\n      return utils.buildRegex(triggerFilter).test(trigger.description);\n    });\n  } else {\n    return _.filter(triggers, trigger => {\n      return trigger.description === triggerFilter;\n    });\n  }\n}\n\nexport function toDataFrame(problems: any[]): DataFrame {\n  const problemsField: Field<any> = {\n    name: 'Problems',\n    type: FieldType.other,\n    values: new ArrayVector(problems),\n    config: {},\n  };\n\n  const response: DataFrame = {\n    name: 'problems',\n    fields: [problemsField],\n    length: problems.length,\n  };\n\n  return response;\n}\n\nconst problemsHandler = {\n  addTriggerDataSource,\n  addTriggerHostProxy,\n  setMaintenanceStatus,\n  setAckButtonStatus,\n  filterTriggersPre,\n  toDataFrame,\n  joinTriggersWithProblems,\n  joinTriggersWithEvents,\n};\n\nexport default problemsHandler;\n","/**\n * This module allows to deduplicate function calls with the same params and\n * cache result of function call.\n */\n\nexport class CachingProxy {\n  cacheEnabled: boolean;\n  ttl: number;\n  cache: any;\n  promises: any;\n\n  constructor(cacheOptions) {\n    this.cacheEnabled = cacheOptions.enabled;\n    this.ttl          = cacheOptions.ttl || 600000; // 10 minutes by default\n\n    // Internal objects for data storing\n    this.cache = {};\n    this.promises = {};\n  }\n\n  /**\n   * Check that result is present in the cache and is up to date or send request otherwise.\n   */\n  cacheRequest(func, funcName, funcScope) {\n    return cacheRequest(func, funcName, funcScope, this);\n  }\n\n  /**\n   * Wrap request to prevent multiple calls with same params when request is waiting for response.\n   */\n  proxyfy(func, funcName, funcScope) {\n    if (!this.promises[funcName]) {\n      this.promises[funcName] = {};\n    }\n    const promiseKeeper = this.promises[funcName];\n    return callOnce(func, promiseKeeper, funcScope);\n  }\n\n  proxyfyWithCache(func, funcName, funcScope) {\n    const proxyfied = this.proxyfy(func, funcName, funcScope);\n    return this.cacheRequest(proxyfied, funcName, funcScope);\n  }\n\n  _isExpired(cacheObject) {\n    if (cacheObject) {\n      const object_age = Date.now() - cacheObject.timestamp;\n      return !(cacheObject.timestamp && object_age < this.ttl);\n    } else {\n      return true;\n    }\n  }\n}\n\n/**\n * Wrap request to prevent multiple calls\n * with same params when waiting for result.\n */\nfunction callOnce(func, promiseKeeper, funcScope) {\n  // tslint:disable-next-line: only-arrow-functions\n  return function() {\n    const hash = getRequestHash(arguments);\n    if (!promiseKeeper[hash]) {\n      promiseKeeper[hash] = Promise.resolve(\n        func.apply(funcScope, arguments)\n        .then(result => {\n          promiseKeeper[hash] = null;\n          return result;\n        })\n      );\n    }\n    return promiseKeeper[hash];\n  };\n}\n\nfunction cacheRequest(func, funcName, funcScope, self) {\n  // tslint:disable-next-line: only-arrow-functions\n  return function() {\n    if (!self.cache[funcName]) {\n      self.cache[funcName] = {};\n    }\n\n    const cacheObject = self.cache[funcName];\n    const hash = getRequestHash(arguments);\n    if (self.cacheEnabled && !self._isExpired(cacheObject[hash])) {\n      return Promise.resolve(cacheObject[hash].value);\n    } else {\n      return func.apply(funcScope, arguments)\n      .then(result => {\n        if (result !== undefined) {\n          cacheObject[hash] = {\n            value: result,\n            timestamp: Date.now()\n          };\n        }\n        return result;\n      });\n    }\n  };\n}\n\nfunction getRequestHash(args) {\n  const argsJson = JSON.stringify(args);\n  return getHash(argsJson);\n}\n\nfunction getHash(str: string): number {\n  let hash = 0, i, chr, len;\n  if (str.length !== 0) {\n    for (i = 0, len = str.length; i < len; i++) {\n      chr   = str.charCodeAt(i);\n      hash  = ((hash << 5) - hash) + chr;\n      hash |= 0; // Convert to 32bit integer\n    }\n  }\n  return hash;\n}\n","import _ from 'lodash';\nimport { getDataSourceSrv } from '@grafana/runtime';\n\nexport const DEFAULT_QUERY_LIMIT = 10000;\nexport const HISTORY_TO_TABLE_MAP = {\n  '0': 'history',\n  '1': 'history_str',\n  '2': 'history_log',\n  '3': 'history_uint',\n  '4': 'history_text'\n};\n\nexport const TREND_TO_TABLE_MAP = {\n  '0': 'trends',\n  '3': 'trends_uint'\n};\n\nexport const consolidateByFunc = {\n  'avg': 'AVG',\n  'min': 'MIN',\n  'max': 'MAX',\n  'sum': 'SUM',\n  'count': 'COUNT'\n};\n\nexport const consolidateByTrendColumns = {\n  'avg': 'value_avg',\n  'min': 'value_min',\n  'max': 'value_max',\n  'sum': 'num*value_avg' // sum of sums inside the one-hour trend period\n};\n\n/**\n * Base class for external history database connectors. Subclasses should implement `getHistory()`, `getTrends()` and\n * `testDataSource()` methods, which describe how to fetch data from source other than Zabbix API.\n */\nexport class DBConnector {\n  constructor(options) {\n    this.datasourceId = options.datasourceId;\n    this.datasourceName = options.datasourceName;\n    this.datasourceTypeId = null;\n    this.datasourceTypeName = null;\n  }\n\n  static loadDatasource(dsId, dsName) {\n    if (!dsName && dsId !== undefined) {\n      let ds = _.find(getDataSourceSrv().getAll(), {'id': dsId});\n      if (!ds) {\n        return Promise.reject(`Data Source with ID ${dsId} not found`);\n      }\n      dsName = ds.name;\n    }\n    if (dsName) {\n      return getDataSourceSrv().loadDatasource(dsName);\n    } else {\n      return Promise.reject(`Data Source name should be specified`);\n    }\n  }\n\n  loadDBDataSource() {\n    return DBConnector.loadDatasource(this.datasourceId, this.datasourceName)\n    .then(ds => {\n      this.datasourceTypeId = ds.meta.id;\n      this.datasourceTypeName = ds.meta.name;\n      if (!this.datasourceName) {\n        this.datasourceName = ds.name;\n      }\n      if (!this.datasourceId) {\n        this.datasourceId = ds.id;\n      }\n      return ds;\n    });\n  }\n\n  /**\n   * Send test request to datasource in order to ensure it's working.\n   */\n  testDataSource() {\n    throw new ZabbixNotImplemented('testDataSource()');\n  }\n\n  /**\n   * Get history data from external sources.\n   */\n  getHistory() {\n    throw new ZabbixNotImplemented('getHistory()');\n  }\n\n  /**\n   * Get trends data from external sources.\n   */\n  getTrends() {\n    throw new ZabbixNotImplemented('getTrends()');\n  }\n\n  handleGrafanaTSResponse(history, items, addHostName = true) {\n    return convertGrafanaTSResponse(history, items, addHostName);\n  }\n}\n\n// Define Zabbix DB Connector exception type for non-implemented methods\nexport class ZabbixNotImplemented {\n  constructor(methodName) {\n    this.code = null;\n    this.name = 'ZabbixNotImplemented';\n    this.message = `Zabbix DB Connector Error: method ${methodName || ''} should be implemented in subclass of DBConnector`;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n\n/**\n * Converts time series returned by the data source into format that Grafana expects\n * time_series is Array of series:\n * ```\n * [{\n *     name: string,\n *     points: Array<[value: number, timestamp: number]>\n * }]\n * ```\n */\nfunction convertGrafanaTSResponse(time_series, items, addHostName) {\n  //uniqBy is needed to deduplicate\n  const hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid');\n  let grafanaSeries = _.map(_.compact(time_series), series => {\n    const itemid = series.name;\n    const item = _.find(items, {'itemid': itemid});\n    let alias = item.name;\n\n    // Add scopedVars for using in alias functions\n    const scopedVars = {\n      '__zbx_item': { value: item.name },\n      '__zbx_item_name': { value: item.name },\n      '__zbx_item_key': { value: item.key_ },\n    };\n\n    if (_.keys(hosts).length > 0) {\n      const host = _.find(hosts, {'hostid': item.hostid});\n      scopedVars['__zbx_host'] = { value: host.host };\n      scopedVars['__zbx_host_name'] = { value: host.name };\n\n      // Only add host when multiple hosts selected\n      if (_.keys(hosts).length > 1 && addHostName) {\n        alias = host.name + \": \" + alias;\n      }\n    }\n    // CachingProxy deduplicates requests and returns one time series for equal queries.\n    // Clone is needed to prevent changing of series object shared between all targets.\n    const datapoints = _.cloneDeep(series.points);\n    return {\n      target: alias,\n      datapoints,\n      scopedVars,\n    };\n  });\n\n  return _.sortBy(grafanaSeries, 'target');\n}\n\nconst defaults = {\n  DBConnector,\n  DEFAULT_QUERY_LIMIT,\n  HISTORY_TO_TABLE_MAP,\n  TREND_TO_TABLE_MAP,\n  consolidateByFunc,\n  consolidateByTrendColumns\n};\n\nexport default defaults;\n","/**\n * General Zabbix API methods\n */\nimport { getBackendSrv } from '@grafana/runtime';\nimport { JSONRPCRequest, ZabbixRequestResponse, JSONRPCError, APILoginResponse, GFHTTPRequest, GFRequestOptions } from './types';\n\nexport class ZabbixAPICore {\n  /**\n   * Request data from Zabbix API\n   * @return {object}  response.result\n   */\n  request(api_url: string, method: string, params: any, options: GFRequestOptions, auth?: string) {\n    const requestData: JSONRPCRequest = {\n      jsonrpc: '2.0',\n      method: method,\n      params: params,\n      id: 1\n    };\n\n    if (auth === \"\") {\n      // Reject immediately if not authenticated\n      return Promise.reject(new ZabbixAPIError({data: \"Not initialized\"}));\n    } else if (auth) {\n      // Set auth parameter only if it needed\n      requestData.auth = auth;\n    }\n\n    const requestOptions: GFHTTPRequest = {\n      method: 'POST',\n      url: api_url,\n      data: requestData,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    };\n\n    // Set request options for basic auth\n    if (options.basicAuth || options.withCredentials) {\n      requestOptions.withCredentials = true;\n    }\n    if (options.basicAuth) {\n      requestOptions.headers.Authorization = options.basicAuth;\n    }\n\n    return this.datasourceRequest(requestOptions);\n  }\n\n  datasourceRequest(requestOptions) {\n    return getBackendSrv().datasourceRequest(requestOptions)\n    .then((response: ZabbixRequestResponse) => {\n      if (!response?.data) {\n        return Promise.reject(new ZabbixAPIError({data: \"General Error, no data\"}));\n      } else if (response?.data.error) {\n\n        // Handle Zabbix API errors\n        return Promise.reject(new ZabbixAPIError(response.data.error));\n      }\n\n      // Success\n      return response?.data.result;\n    });\n  }\n\n  /**\n   * Get authentication token.\n   * @return {string}  auth token\n   */\n  login(api_url: string, username: string, password: string, options: GFRequestOptions): Promise<APILoginResponse> {\n    const params = {\n      user: username,\n      password: password\n    };\n    return this.request(api_url, 'user.login', params, options, null);\n  }\n\n  /**\n   * Get Zabbix API version\n   * Matches the version of Zabbix starting from Zabbix 2.0.4\n   */\n  getVersion(api_url: string, options: GFRequestOptions): Promise<string> {\n    return this.request(api_url, 'apiinfo.version', [], options).catch(err => {\n      console.error(err);\n      return undefined;\n    });\n  }\n}\n\n// Define zabbix API exception type\nexport class ZabbixAPIError {\n  code: number;\n  name: string;\n  data: string;\n  message: string;\n\n  constructor(error: JSONRPCError) {\n    this.code = error.code || null;\n    this.name = error.message || \"\";\n    this.data = error.data || \"\";\n    this.message = \"Zabbix API Error: \" + this.name + \" \" + this.data;\n  }\n\n  toString() {\n    return this.name + \" \" + this.data;\n  }\n}\n","import _ from 'lodash';\nimport semver from 'semver';\nimport kbn from 'grafana/app/core/utils/kbn';\nimport * as utils from '../../../utils';\nimport { ZabbixAPICore } from './zabbixAPICore';\nimport { ZBX_ACK_ACTION_NONE, ZBX_ACK_ACTION_ACK, ZBX_ACK_ACTION_ADD_MESSAGE, MIN_SLA_INTERVAL } from '../../../constants';\nimport { ShowProblemTypes, ZBXProblem } from '../../../types';\nimport { JSONRPCRequestParams } from './types';\n\nconst DEFAULT_ZABBIX_VERSION = '3.0.0';\n\n/**\n * Zabbix API Wrapper.\n * Creates Zabbix API instance with given parameters (url, credentials and other).\n * Wraps API calls and provides high-level methods.\n */\nexport class ZabbixAPIConnector {\n  url: string;\n  username: string;\n  password: string;\n  auth: string;\n  requestOptions: { basicAuth: any; withCredentials: boolean; };\n  loginPromise: Promise<string>;\n  loginErrorCount: number;\n  maxLoginAttempts: number;\n  zabbixAPICore: ZabbixAPICore;\n  getTrend: (items: any, timeFrom: any, timeTill: any) => Promise<any[]>;\n  version: string;\n  getVersionPromise: Promise<string>;\n\n  constructor(api_url: string, username: string, password: string, basicAuth: any, withCredentials: boolean) {\n    this.url              = api_url;\n    this.username         = username;\n    this.password         = password;\n    this.auth             = '';\n\n    this.requestOptions = {\n      basicAuth: basicAuth,\n      withCredentials: withCredentials\n    };\n\n    this.loginPromise = null;\n    this.loginErrorCount = 0;\n    this.maxLoginAttempts = 3;\n\n    this.zabbixAPICore = new ZabbixAPICore();\n\n    this.getTrend = this.getTrend_ZBXNEXT1193;\n    //getTrend = getTrend_30;\n\n    this.initVersion();\n  }\n\n  //////////////////////////\n  // Core method wrappers //\n  //////////////////////////\n\n  request(method: string, params: JSONRPCRequestParams): Promise<any> {\n    if (!this.version) {\n      return this.initVersion().then(() => this.request(method, params));\n    }\n\n    return this.zabbixAPICore.request(this.url, method, params, this.requestOptions, this.auth)\n    .catch(error => {\n      if (isNotInitialized(error.data)) {\n        // If API not initialized yet (auth is empty), login first\n        return this.loginOnce()\n        .then(() => this.request(method, params));\n      } else if (isNotAuthorized(error.data)) {\n        // Handle auth errors\n        this.loginErrorCount++;\n        if (this.loginErrorCount > this.maxLoginAttempts) {\n          this.loginErrorCount = 0;\n          return Promise.resolve();\n        } else {\n          return this.loginOnce()\n          .then(() => this.request(method, params));\n        }\n      } else {\n        return Promise.reject(error);\n      }\n    });\n  }\n\n  /**\n   * When API unauthenticated or auth token expired each request produce login()\n   * call. But auth token is common to all requests. This function wraps login() method\n   * and call it once. If login() already called just wait for it (return its promise).\n   */\n  loginOnce(): Promise<string> {\n    if (!this.loginPromise) {\n      this.loginPromise = Promise.resolve(\n        this.login().then(auth => {\n          this.auth = auth;\n          this.loginPromise = null;\n          return auth;\n        })\n      );\n    }\n    return this.loginPromise;\n  }\n\n  /**\n   * Get authentication token.\n   */\n  login(): Promise<string> {\n    return this.zabbixAPICore.login(this.url, this.username, this.password, this.requestOptions);\n  }\n\n  /**\n   * Get Zabbix API version\n   */\n  getVersion() {\n    return this.zabbixAPICore.getVersion(this.url, this.requestOptions);\n  }\n\n  initVersion(): Promise<string> {\n    if (!this.getVersionPromise) {\n      this.getVersionPromise = Promise.resolve(\n        this.getVersion().then(version => {\n          if (version) {\n            console.log(`Zabbix version detected: ${version}`);\n          } else {\n            console.log(`Failed to detect Zabbix version, use default ${DEFAULT_ZABBIX_VERSION}`);\n          }\n\n          this.version = version || DEFAULT_ZABBIX_VERSION;\n          this.getVersionPromise = null;\n          return version;\n        })\n      );\n    }\n    return this.getVersionPromise;\n  }\n\n  ////////////////////////////////\n  // Zabbix API method wrappers //\n  ////////////////////////////////\n\n  acknowledgeEvent(eventid: string, message: string, action?: number, severity?: number) {\n    if (!action) {\n      action = semver.gte(this.version, '4.0.0') ? ZBX_ACK_ACTION_ADD_MESSAGE : ZBX_ACK_ACTION_NONE;\n    }\n\n    const params: any = {\n      eventids: eventid,\n      message: message,\n      action: action\n    };\n\n    if (severity) {\n      params.severity = severity;\n    }\n\n    return this.request('event.acknowledge', params);\n  }\n\n  getGroups() {\n    const params = {\n      output: ['name'],\n      sortfield: 'name',\n      real_hosts: true\n    };\n\n    return this.request('hostgroup.get', params);\n  }\n\n  getHosts(groupids) {\n    const params: any = {\n      output: ['name', 'host'],\n      sortfield: 'name'\n    };\n    if (groupids) {\n      params.groupids = groupids;\n    }\n\n    return this.request('host.get', params);\n  }\n\n  getApps(hostids): Promise<any[]> {\n    const params = {\n      output: 'extend',\n      hostids: hostids\n    };\n\n    return this.request('application.get', params);\n  }\n\n  /**\n   * Get Zabbix items\n   * @param  {[type]} hostids  host ids\n   * @param  {[type]} appids   application ids\n   * @param  {String} itemtype 'num' or 'text'\n   * @return {[type]}          array of items\n   */\n  getItems(hostids, appids, itemtype) {\n    const params: any = {\n      output: [\n        'name', 'key_',\n        'value_type',\n        'hostid',\n        'status',\n        'state'\n      ],\n      sortfield: 'name',\n      webitems: true,\n      filter: {},\n      selectHosts: ['hostid', 'name', 'host']\n    };\n    if (hostids) {\n      params.hostids = hostids;\n    }\n    if (appids) {\n      params.applicationids = appids;\n    }\n    if (itemtype === 'num') {\n      // Return only numeric metrics\n      params.filter.value_type = [0, 3];\n    }\n    if (itemtype === 'text') {\n      // Return only text metrics\n      params.filter.value_type = [1, 2, 4];\n    }\n\n    return this.request('item.get', params)\n    .then(utils.expandItems);\n  }\n\n  getItemsByIDs(itemids) {\n    const params = {\n      itemids: itemids,\n      output: [\n        'name', 'key_',\n        'value_type',\n        'hostid',\n        'status',\n        'state'\n      ],\n      webitems: true,\n      selectHosts: ['hostid', 'name']\n    };\n\n    return this.request('item.get', params)\n    .then(items => utils.expandItems(items));\n  }\n\n  getMacros(hostids) {\n    const params = {\n      output: 'extend',\n      hostids: hostids\n    };\n\n    return this.request('usermacro.get', params);\n  }\n\n  getGlobalMacros() {\n    const params = {\n      output: 'extend',\n      globalmacro: true\n    };\n\n    return this.request('usermacro.get', params);\n  }\n\n  getLastValue(itemid) {\n    const params = {\n      output: ['lastvalue'],\n      itemids: itemid\n    };\n    return this.request('item.get', params)\n    .then(items => items.length ? items[0].lastvalue : null);\n  }\n\n  /**\n   * Perform history query from Zabbix API\n   *\n   * @param  {Array}  items       Array of Zabbix item objects\n   * @param  {Number} timeFrom   Time in seconds\n   * @param  {Number} timeTill   Time in seconds\n   * @return {Array}  Array of Zabbix history objects\n   */\n  getHistory(items, timeFrom, timeTill) {\n\n    // Group items by value type and perform request for each value type\n    const grouped_items = _.groupBy(items, 'value_type');\n    const promises = _.map(grouped_items, (items, value_type) => {\n      const itemids = _.map(items, 'itemid');\n      const params: any = {\n        output: 'extend',\n        history: value_type,\n        itemids: itemids,\n        sortfield: 'clock',\n        sortorder: 'ASC',\n        time_from: timeFrom\n      };\n\n      // Relative queries (e.g. last hour) don't include an end time\n      if (timeTill) {\n        params.time_till = timeTill;\n      }\n\n      return this.request('history.get', params);\n    });\n\n    return Promise.all(promises).then(_.flatten);\n  }\n\n  /**\n   * Perform trends query from Zabbix API\n   * Use trends api extension from ZBXNEXT-1193 patch.\n   *\n   * @param  {Array}  items       Array of Zabbix item objects\n   * @param  {Number} time_from   Time in seconds\n   * @param  {Number} time_till   Time in seconds\n   * @return {Array}  Array of Zabbix trend objects\n   */\n  getTrend_ZBXNEXT1193(items, timeFrom, timeTill) {\n\n    // Group items by value type and perform request for each value type\n    const grouped_items = _.groupBy(items, 'value_type');\n    const promises = _.map(grouped_items, (items, value_type) => {\n      const itemids = _.map(items, 'itemid');\n      const params: any = {\n        output: 'extend',\n        trend: value_type,\n        itemids: itemids,\n        sortfield: 'clock',\n        sortorder: 'ASC',\n        time_from: timeFrom\n      };\n\n      // Relative queries (e.g. last hour) don't include an end time\n      if (timeTill) {\n        params.time_till = timeTill;\n      }\n\n      return this.request('trend.get', params);\n    });\n\n    return Promise.all(promises).then(_.flatten);\n  }\n\n  getTrend_30(items, time_from, time_till, value_type) {\n    const self = this;\n    const itemids = _.map(items, 'itemid');\n\n    const params: any = {\n      output: [\"itemid\",\n        \"clock\",\n        value_type\n      ],\n      itemids: itemids,\n      time_from: time_from\n    };\n\n    // Relative queries (e.g. last hour) don't include an end time\n    if (time_till) {\n      params.time_till = time_till;\n    }\n\n    return self.request('trend.get', params);\n  }\n\n  getITService(serviceids?) {\n    const params = {\n      output: 'extend',\n      serviceids: serviceids\n    };\n    return this.request('service.get', params);\n  }\n\n  getSLA(serviceids, timeRange, options) {\n    const [timeFrom, timeTo] = timeRange;\n    let intervals = [{ from: timeFrom, to: timeTo }];\n    if (options.slaInterval === 'auto') {\n      const interval = getSLAInterval(options.intervalMs);\n      intervals = buildSLAIntervals(timeRange, interval);\n    } else if (options.slaInterval !== 'none') {\n      const interval = utils.parseInterval(options.slaInterval) / 1000;\n      intervals = buildSLAIntervals(timeRange, interval);\n    }\n\n    const params: any = {\n      serviceids,\n      intervals\n    };\n\n    return this.request('service.getsla', params);\n  }\n\n  getProblems(groupids, hostids, applicationids, options): Promise<ZBXProblem[]> {\n    const { timeFrom, timeTo, recent, severities, limit, acknowledged } = options;\n\n    const params: any = {\n      output: 'extend',\n      selectAcknowledges: 'extend',\n      selectSuppressionData: 'extend',\n      selectTags: 'extend',\n      source: '0',\n      object: '0',\n      sortfield: ['eventid'],\n      sortorder: 'ASC',\n      evaltype: '0',\n      // preservekeys: '1',\n      groupids,\n      hostids,\n      applicationids,\n      recent,\n    };\n\n    if (severities) {\n      params.severities = severities;\n    }\n\n    if (acknowledged !== undefined) {\n      params.acknowledged = acknowledged;\n    }\n\n    if (limit) {\n      params.limit = limit;\n    }\n\n    if (timeFrom || timeTo) {\n      params.time_from = timeFrom;\n      params.time_till = timeTo;\n    }\n\n    return this.request('problem.get', params).then(utils.mustArray);\n  }\n\n  getTriggersByIds(triggerids: string[]) {\n    const params: any = {\n      output: 'extend',\n      triggerids: triggerids,\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      selectGroups: ['name'],\n      selectHosts: ['name', 'host', 'maintenance_status', 'proxy_hostid'],\n      selectItems: ['name', 'key_', 'lastvalue'],\n      // selectLastEvent: 'extend',\n      // selectTags: 'extend',\n      preservekeys: '1',\n    };\n\n    return this.request('trigger.get', params).then(utils.mustArray);\n  }\n\n  getTriggers(groupids, hostids, applicationids, options) {\n    const {showTriggers, maintenance, timeFrom, timeTo} = options;\n\n    const params: any = {\n      output: 'extend',\n      groupids: groupids,\n      hostids: hostids,\n      applicationids: applicationids,\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      //only_true: true,\n      filter: {\n        value: 1\n      },\n      selectGroups: ['name'],\n      selectHosts: ['name', 'host', 'maintenance_status', 'proxy_hostid'],\n      selectItems: ['name', 'key_', 'lastvalue'],\n      selectLastEvent: 'extend',\n      selectTags: 'extend'\n    };\n\n    if (showTriggers === ShowProblemTypes.Problems) {\n      params.filter.value = 1;\n    } else if (showTriggers === ShowProblemTypes.Recent || showTriggers === ShowProblemTypes.History) {\n      params.filter.value = [0, 1];\n    }\n\n    if (maintenance) {\n      params.maintenance = true;\n    }\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params);\n  }\n\n  getEvents(objectids, timeFrom, timeTo, showEvents, limit) {\n    const params: any = {\n      output: 'extend',\n      time_from: timeFrom,\n      time_till: timeTo,\n      objectids: objectids,\n      select_acknowledges: 'extend',\n      selectHosts: 'extend',\n      value: showEvents,\n    };\n\n    if (limit) {\n      params.limit = limit;\n      params.sortfield = 'clock';\n      params.sortorder = 'DESC';\n    }\n\n    return this.request('event.get', params).then(utils.mustArray);\n  }\n\n  getEventsHistory(groupids, hostids, applicationids, options) {\n    const { timeFrom, timeTo, severities, limit, value } = options;\n\n    const params: any = {\n      output: 'extend',\n      time_from: timeFrom,\n      time_till: timeTo,\n      value: '1',\n      source: '0',\n      object: '0',\n      evaltype: '0',\n      sortfield: ['eventid'],\n      sortorder: 'ASC',\n      select_acknowledges: 'extend',\n      selectTags: 'extend',\n      selectSuppressionData: ['maintenanceid', 'suppress_until'],\n      groupids,\n      hostids,\n      applicationids,\n    };\n\n    if (limit) {\n      params.limit = limit;\n    }\n\n    if (severities) {\n      params.severities = severities;\n    }\n\n    if (value) {\n      params.value = value;\n    }\n\n    return this.request('event.get', params).then(utils.mustArray);\n  }\n\n  getExtendedEventData(eventids) {\n    const params = {\n      output: 'extend',\n      eventids: eventids,\n      preservekeys: true,\n      select_acknowledges: 'extend',\n      selectTags: 'extend',\n      sortfield: 'clock',\n      sortorder: 'DESC'\n    };\n\n    return this.request('event.get', params);\n  }\n\n  getEventAlerts(eventids) {\n    const params = {\n      eventids: eventids,\n      output: [\n        'eventid',\n        'message',\n        'clock',\n        'error'\n      ],\n      selectUsers: true,\n    };\n\n    return this.request('alert.get', params);\n  }\n\n  getAcknowledges(eventids) {\n    const params = {\n      output: 'extend',\n      eventids: eventids,\n      preservekeys: true,\n      select_acknowledges: 'extend',\n      sortfield: 'clock',\n      sortorder: 'DESC'\n    };\n\n    return this.request('event.get', params)\n    .then(events => {\n      return _.filter(events, (event) => event.acknowledges.length);\n    });\n  }\n\n  getAlerts(itemids, timeFrom, timeTo) {\n    const params: any = {\n      output: 'extend',\n      itemids: itemids,\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      //only_true: true,\n      // filter: {\n      //   value: 1\n      // },\n      selectLastEvent: 'extend'\n    };\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params);\n  }\n\n  getHostAlerts(hostids, applicationids, options) {\n    const {minSeverity, acknowledged, count, timeFrom, timeTo} = options;\n    const params: any = {\n      output: 'extend',\n      hostids: hostids,\n      min_severity: minSeverity,\n      filter: { value: 1 },\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      selectLastEvent: 'extend',\n      selectGroups: 'extend',\n      selectHosts: ['host', 'name']\n    };\n\n    if (count && acknowledged !== 0 && acknowledged !== 1) {\n      params.countOutput = true;\n    }\n\n    if (applicationids && applicationids.length) {\n      params.applicationids = applicationids;\n    }\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params)\n    .then((triggers) => {\n      if (!count || acknowledged === 0 || acknowledged === 1) {\n        triggers = filterTriggersByAcknowledge(triggers, acknowledged);\n        if (count) {\n          triggers = triggers.length;\n        }\n      }\n      return triggers;\n    });\n  }\n\n  getProxies() {\n    const params = {\n      output: ['proxyid', 'host'],\n    };\n\n    return this.request('proxy.get', params);\n  }\n}\n\nfunction filterTriggersByAcknowledge(triggers, acknowledged) {\n  if (acknowledged === 0) {\n    return _.filter(triggers, (trigger) => trigger.lastEvent.acknowledged === \"0\");\n  } else if (acknowledged === 1) {\n    return _.filter(triggers, (trigger) => trigger.lastEvent.acknowledged === \"1\");\n  } else {\n    return triggers;\n  }\n}\n\nfunction isNotInitialized(message) {\n  return message === \"Not initialized\";\n}\n\nfunction isNotAuthorized(message) {\n  return (\n    message === \"Session terminated, re-login, please.\" ||\n    message === \"Not authorised.\" ||\n    message === \"Not authorized.\"\n  );\n}\n\nfunction getSLAInterval(intervalMs) {\n  // Too many intervals may cause significant load on the database, so decrease number of resulting points\n  const resolutionRatio = 100;\n  const interval = kbn.round_interval(intervalMs * resolutionRatio) / 1000;\n  return Math.max(interval, MIN_SLA_INTERVAL);\n}\n\nfunction buildSLAIntervals(timeRange, interval) {\n  let [timeFrom, timeTo] = timeRange;\n  const intervals = [];\n\n  // Align time range with calculated interval\n  timeFrom = Math.floor(timeFrom / interval) * interval;\n  timeTo = Math.ceil(timeTo / interval) * interval;\n\n  for (let i = timeFrom; i <= timeTo - interval; i += interval) {\n    intervals.push({\n      from : i,\n      to : (i + interval)\n    });\n\n  }\n\n  return intervals;\n}\n","/**\n * MySQL queries\n */\n\nfunction historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction) {\n  let query = `\n    SELECT CAST(itemid AS CHAR) AS metric, MIN(clock) AS time_sec, ${aggFunction}(value) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY (clock-${timeFrom}) DIV ${intervalSec}, metric\n    ORDER BY time_sec ASC\n  `;\n  return query;\n}\n\nfunction trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn) {\n  let query = `\n    SELECT CAST(itemid AS CHAR) AS metric, MIN(clock) AS time_sec, ${aggFunction}(${valueColumn}) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY (clock-${timeFrom}) DIV ${intervalSec}, metric\n    ORDER BY time_sec ASC\n  `;\n  return query;\n}\n\nconst TEST_QUERY = `SELECT CAST(itemid AS CHAR) AS metric, clock AS time_sec, value_avg AS value FROM trends_uint LIMIT 1`;\n\nfunction testQuery() {\n  return TEST_QUERY;\n}\n\nconst mysql = {\n  historyQuery,\n  trendsQuery,\n  testQuery\n};\n\nexport default mysql;\n","/**\n * Postgres queries\n */\n\nconst ITEMID_FORMAT = 'FM99999999999999999999';\n\nfunction historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction) {\n  let time_expression = `clock / ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, ${time_expression} AS time, ${aggFunction}(value) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY 1, 2\n    ORDER BY time ASC\n  `;\n  return query;\n}\n\nfunction trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn) {\n  let time_expression = `clock / ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, ${time_expression} AS time, ${aggFunction}(${valueColumn}) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY 1, 2\n    ORDER BY time ASC\n  `;\n  return query;\n}\n\nconst TEST_QUERY = `\n  SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, clock AS time, value_avg AS value\n  FROM trends_uint LIMIT 1\n`;\n\nfunction testQuery() {\n  return TEST_QUERY;\n}\n\nconst postgres = {\n  historyQuery,\n  trendsQuery,\n  testQuery\n};\n\nexport default postgres;\n","import _ from 'lodash';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { compactQuery } from '../../../utils';\nimport mysql from './mysql';\nimport postgres from './postgres';\nimport dbConnector, { DBConnector, DEFAULT_QUERY_LIMIT, HISTORY_TO_TABLE_MAP, TREND_TO_TABLE_MAP } from '../dbConnector';\n\nconst supportedDatabases = {\n  mysql: 'mysql',\n  postgres: 'postgres'\n};\n\nexport class SQLConnector extends DBConnector {\n  constructor(options) {\n    super(options);\n\n    this.limit = options.limit || DEFAULT_QUERY_LIMIT;\n    this.sqlDialect = null;\n\n    super.loadDBDataSource()\n    .then(() => {\n      this.loadSQLDialect();\n    });\n  }\n\n  loadSQLDialect() {\n    if (this.datasourceTypeId === supportedDatabases.postgres) {\n      this.sqlDialect = postgres;\n    } else {\n      this.sqlDialect = mysql;\n    }\n  }\n\n  /**\n   * Try to invoke test query for one of Zabbix database tables.\n   */\n  testDataSource() {\n    let testQuery = this.sqlDialect.testQuery();\n    return this.invokeSQLQuery(testQuery);\n  }\n\n  getHistory(items, timeFrom, timeTill, options) {\n    let {intervalMs, consolidateBy} = options;\n    let intervalSec = Math.ceil(intervalMs / 1000);\n\n    // The interval must match the time range exactly n times, otherwise\n    // the resulting first and last data points will yield invalid values in the\n    // calculated average value in downsampleSeries - when using consolidateBy(avg)\n    let numOfIntervals = Math.ceil((timeTill - timeFrom) / intervalSec);\n    intervalSec = (timeTill - timeFrom) / numOfIntervals;\n\n    consolidateBy = consolidateBy || 'avg';\n    let aggFunction = dbConnector.consolidateByFunc[consolidateBy];\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid').join(', ');\n      let table = HISTORY_TO_TABLE_MAP[value_type];\n      let query = this.sqlDialect.historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction);\n\n      query = compactQuery(query);\n      return this.invokeSQLQuery(query);\n    });\n\n    return Promise.all(promises).then(results => {\n      return _.flatten(results);\n    });\n  }\n\n  getTrends(items, timeFrom, timeTill, options) {\n    let { intervalMs, consolidateBy } = options;\n    let intervalSec = Math.ceil(intervalMs / 1000);\n\n    // The interval must match the time range exactly n times, otherwise\n    // the resulting first and last data points will yield invalid values in the\n    // calculated average value in downsampleSeries - when using consolidateBy(avg)\n    let numOfIntervals = Math.ceil((timeTill - timeFrom) / intervalSec);\n    intervalSec = (timeTill - timeFrom) / numOfIntervals;\n\n    consolidateBy = consolidateBy || 'avg';\n    let aggFunction = dbConnector.consolidateByFunc[consolidateBy];\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid').join(', ');\n      let table = TREND_TO_TABLE_MAP[value_type];\n      let valueColumn = _.includes(['avg', 'min', 'max', 'sum'], consolidateBy) ? consolidateBy : 'avg';\n      valueColumn = dbConnector.consolidateByTrendColumns[valueColumn];\n      let query = this.sqlDialect.trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn);\n\n      query = compactQuery(query);\n      return this.invokeSQLQuery(query);\n    });\n\n    return Promise.all(promises).then(results => {\n      return _.flatten(results);\n    });\n  }\n\n  invokeSQLQuery(query) {\n    let queryDef = {\n      refId: 'A',\n      format: 'time_series',\n      datasourceId: this.datasourceId,\n      rawSql: query,\n      maxDataPoints: this.limit\n    };\n\n    return getBackendSrv().datasourceRequest({\n      url: '/api/tsdb/query',\n      method: 'POST',\n      data: {\n        queries: [queryDef],\n      }\n    })\n    .then(response => {\n      let results = response.data.results;\n      if (results['A']) {\n        return results['A'].series;\n      } else {\n        return null;\n      }\n    });\n  }\n}\n","import _ from 'lodash';\nimport { compactQuery } from '../../../utils';\nimport { DBConnector, HISTORY_TO_TABLE_MAP, consolidateByTrendColumns } from '../dbConnector';\n\nconst consolidateByFunc = {\n  'avg': 'MEAN',\n  'min': 'MIN',\n  'max': 'MAX',\n  'sum': 'SUM',\n  'count': 'COUNT'\n};\n\nexport class InfluxDBConnector extends DBConnector {\n  constructor(options) {\n    super(options);\n    this.retentionPolicy = options.retentionPolicy;\n    super.loadDBDataSource().then(ds => {\n      this.influxDS = ds;\n      return ds;\n    });\n  }\n\n  /**\n   * Try to invoke test query for one of Zabbix database tables.\n   */\n  testDataSource() {\n    return this.influxDS.testDatasource().then(result => {\n      if (result.status && result.status === 'error') {\n        return Promise.reject({ data: {\n          message: `InfluxDB connection error: ${result.message}`\n        }});\n      }\n      return result;\n    });\n  }\n\n  getHistory(items, timeFrom, timeTill, options) {\n    let { intervalMs, consolidateBy, retentionPolicy } = options;\n    const intervalSec = Math.ceil(intervalMs / 1000);\n\n    const range = { timeFrom, timeTill };\n    consolidateBy = consolidateBy || 'avg';\n\n    // Group items by value type and perform request for each value type\n    const grouped_items = _.groupBy(items, 'value_type');\n    const promises = _.map(grouped_items, (items, value_type) => {\n      const itemids = _.map(items, 'itemid');\n      const table = HISTORY_TO_TABLE_MAP[value_type];\n      const query = this.buildHistoryQuery(itemids, table, range, intervalSec, consolidateBy, retentionPolicy);\n      return this.invokeInfluxDBQuery(query);\n    });\n\n    return Promise.all(promises)\n    .then(_.flatten)\n    .then(results => {\n      return handleInfluxHistoryResponse(results);\n    });\n  }\n\n  getTrends(items, timeFrom, timeTill, options) {\n    options.retentionPolicy = this.retentionPolicy;\n    return this.getHistory(items, timeFrom, timeTill, options);\n  }\n\n  buildHistoryQuery(itemids, table, range, intervalSec, aggFunction, retentionPolicy) {\n    const { timeFrom, timeTill } = range;\n    const measurement = retentionPolicy ? `\"${retentionPolicy}\".\"${table}\"` : `\"${table}\"`;\n    let value = 'value';\n    if (retentionPolicy) {\n      value = consolidateByTrendColumns[aggFunction] || 'value_avg';\n    }\n    const aggregation = consolidateByFunc[aggFunction] || aggFunction;\n    const where_clause = this.buildWhereClause(itemids);\n    const query = `SELECT ${aggregation}(\"${value}\") FROM ${measurement}\n      WHERE ${where_clause} AND \"time\" >= ${timeFrom}s AND \"time\" <= ${timeTill}s\n      GROUP BY time(${intervalSec}s), \"itemid\" fill(none)`;\n    return compactQuery(query);\n  }\n\n  buildWhereClause(itemids) {\n    const itemidsWhere = itemids.map(itemid => `\"itemid\" = '${itemid}'`).join(' OR ');\n    return `(${itemidsWhere})`;\n  }\n\n  invokeInfluxDBQuery(query) {\n    return this.influxDS._seriesQuery(query)\n    .then(data => data && data.results ? data.results : []);\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nfunction handleInfluxHistoryResponse(results) {\n  if (!results) {\n    return [];\n  }\n\n  const seriesList = [];\n  for (let i = 0; i < results.length; i++) {\n    const result = results[i];\n\n    if (result.error) {\n      const error = `InfluxDB error: ${result.error}`;\n      return Promise.reject(new Error(error));\n    }\n\n    if (!result || !result.series) {\n      continue;\n    }\n\n    const influxSeriesList = results[i].series;\n\n    for (let y = 0; y < influxSeriesList.length; y++) {\n      const influxSeries = influxSeriesList[y];\n      const datapoints = [];\n      if (influxSeries.values) {\n        for (i = 0; i < influxSeries.values.length; i++) {\n          datapoints[i] = [influxSeries.values[i][1], influxSeries.values[i][0]];\n        }\n      }\n      const timeSeries = {\n        name: influxSeries.tags.itemid,\n        points: datapoints\n      };\n      seriesList.push(timeSeries);\n    }\n  }\n\n  return seriesList;\n}\n","import _ from 'lodash';\nimport moment from 'moment';\nimport * as utils from '../utils';\nimport responseHandler from '../responseHandler';\nimport { CachingProxy } from './proxy/cachingProxy';\nimport { ZabbixNotImplemented } from './connectors/dbConnector';\nimport { DBConnector } from './connectors/dbConnector';\nimport { ZabbixAPIConnector } from './connectors/zabbix_api/zabbixAPIConnector';\nimport { SQLConnector } from './connectors/sql/sqlConnector';\nimport { InfluxDBConnector } from './connectors/influxdb/influxdbConnector';\nimport { ZabbixConnector } from './types';\nimport { joinTriggersWithProblems, joinTriggersWithEvents } from '../problemsHandler';\nimport { ProblemDTO } from '../types';\n\ninterface AppsResponse extends Array<any> {\n  appFilterEmpty?: boolean;\n  hostids?: any[];\n}\n\nconst REQUESTS_TO_PROXYFY = [\n  'getHistory', 'getTrend', 'getGroups', 'getHosts', 'getApps', 'getItems', 'getMacros', 'getItemsByIDs',\n  'getEvents', 'getAlerts', 'getHostAlerts', 'getAcknowledges', 'getITService', 'getSLA', 'getVersion', 'getProxies',\n  'getEventAlerts', 'getExtendedEventData', 'getProblems', 'getEventsHistory', 'getTriggersByIds'\n];\n\nconst REQUESTS_TO_CACHE = [\n  'getGroups', 'getHosts', 'getApps', 'getItems', 'getMacros', 'getItemsByIDs', 'getITService', 'getProxies'\n];\n\nconst REQUESTS_TO_BIND = [\n  'getHistory', 'getTrend', 'getMacros', 'getItemsByIDs', 'getEvents', 'getAlerts', 'getHostAlerts',\n  'getAcknowledges', 'getITService', 'getVersion', 'login', 'acknowledgeEvent', 'getProxies', 'getEventAlerts',\n  'getExtendedEventData'\n];\n\nexport class Zabbix implements ZabbixConnector {\n  enableDirectDBConnection: boolean;\n  cachingProxy: CachingProxy;\n  zabbixAPI: ZabbixAPIConnector;\n  getHistoryDB: any;\n  dbConnector: any;\n  getTrendsDB: any;\n\n  getHistory: (items, timeFrom, timeTill) => Promise<any>;\n  getTrend: (items, timeFrom, timeTill) => Promise<any>;\n  getItemsByIDs: (itemids) => Promise<any>;\n  getEvents: (objectids, timeFrom, timeTo, showEvents, limit?) => Promise<any>;\n  getAlerts: (itemids, timeFrom?, timeTo?) => Promise<any>;\n  getHostAlerts: (hostids, applicationids, options?) => Promise<any>;\n  getAcknowledges: (eventids) => Promise<any>;\n  getITService: (serviceids?) => Promise<any>;\n  acknowledgeEvent: (eventid, message) => Promise<any>;\n  getProxies: () => Promise<any>;\n  getEventAlerts: (eventids) => Promise<any>;\n  getExtendedEventData: (eventids) => Promise<any>;\n  getMacros: (hostids: any[]) => Promise<any>;\n  getVersion: () => Promise<string>;\n  login: () => Promise<any>;\n\n  constructor(options) {\n    const {\n      url,\n      username,\n      password,\n      basicAuth,\n      withCredentials,\n      cacheTTL,\n      enableDirectDBConnection,\n      dbConnectionDatasourceId,\n      dbConnectionDatasourceName,\n      dbConnectionRetentionPolicy,\n    } = options;\n\n    this.enableDirectDBConnection = enableDirectDBConnection;\n\n    // Initialize caching proxy for requests\n    const cacheOptions = {\n      enabled: true,\n      ttl: cacheTTL\n    };\n    this.cachingProxy = new CachingProxy(cacheOptions);\n\n    this.zabbixAPI = new ZabbixAPIConnector(url, username, password, basicAuth, withCredentials);\n\n    this.proxyfyRequests();\n    this.cacheRequests();\n    this.bindRequests();\n\n    if (enableDirectDBConnection) {\n      const connectorOptions: any = { dbConnectionRetentionPolicy };\n      this.initDBConnector(dbConnectionDatasourceId, dbConnectionDatasourceName, connectorOptions)\n      .then(() => {\n        this.getHistoryDB = this.cachingProxy.proxyfyWithCache(this.dbConnector.getHistory, 'getHistory', this.dbConnector);\n        this.getTrendsDB = this.cachingProxy.proxyfyWithCache(this.dbConnector.getTrends, 'getTrends', this.dbConnector);\n      });\n    }\n  }\n\n  initDBConnector(datasourceId, datasourceName, options) {\n    return DBConnector.loadDatasource(datasourceId, datasourceName)\n    .then(ds => {\n      const connectorOptions: any = { datasourceId, datasourceName };\n      if (ds.type === 'influxdb') {\n        connectorOptions.retentionPolicy = options.dbConnectionRetentionPolicy;\n        this.dbConnector = new InfluxDBConnector(connectorOptions);\n      } else {\n        this.dbConnector = new SQLConnector(connectorOptions);\n      }\n      return this.dbConnector;\n    });\n  }\n\n  proxyfyRequests() {\n    for (const request of REQUESTS_TO_PROXYFY) {\n      this.zabbixAPI[request] = this.cachingProxy.proxyfy(this.zabbixAPI[request], request, this.zabbixAPI);\n    }\n  }\n\n  cacheRequests() {\n    for (const request of REQUESTS_TO_CACHE) {\n      this.zabbixAPI[request] = this.cachingProxy.cacheRequest(this.zabbixAPI[request], request, this.zabbixAPI);\n    }\n  }\n\n  bindRequests() {\n    for (const request of REQUESTS_TO_BIND) {\n      this[request] = this.zabbixAPI[request].bind(this.zabbixAPI);\n    }\n  }\n\n  /**\n   * Perform test query for Zabbix API and external history DB.\n   * @return {object} test result object:\n   * ```\n   *    {\n   *      zabbixVersion,\n   *      dbConnectorStatus: {\n   *        dsType,\n   *        dsName\n   *      }\n   *    }\n   * ```\n   */\n  testDataSource() {\n    let zabbixVersion;\n    let dbConnectorStatus;\n    return this.getVersion()\n    .then(version => {\n      zabbixVersion = version;\n      return this.login();\n    })\n    .then(() => {\n      if (this.enableDirectDBConnection) {\n        return this.dbConnector.testDataSource();\n      } else {\n        return Promise.resolve();\n      }\n    })\n    .catch(error => {\n      if (error instanceof ZabbixNotImplemented) {\n        return Promise.resolve();\n      }\n      return Promise.reject(error);\n    })\n    .then(testResult => {\n      if (testResult) {\n        dbConnectorStatus = {\n          dsType: this.dbConnector.datasourceTypeName,\n          dsName: this.dbConnector.datasourceName\n        };\n      }\n      return { zabbixVersion, dbConnectorStatus };\n    });\n  }\n\n  getItemsFromTarget(target, options) {\n    const parts = ['group', 'host', 'application', 'item'];\n    const filters = _.map(parts, p => target[p].filter);\n    return this.getItems(...filters, options);\n  }\n\n  getHostsFromTarget(target) {\n    const parts = ['group', 'host', 'application'];\n    const filters = _.map(parts, p => target[p].filter);\n    return Promise.all([\n      this.getHosts(...filters),\n      this.getApps(...filters),\n    ]).then(results => {\n      const hosts = results[0];\n      let apps: AppsResponse = results[1];\n      if (apps.appFilterEmpty) {\n        apps = [];\n      }\n      return [hosts, apps];\n    });\n  }\n\n  getAllGroups() {\n    return this.zabbixAPI.getGroups();\n  }\n\n  getGroups(groupFilter) {\n    return this.getAllGroups()\n    .then(groups => findByFilter(groups, groupFilter));\n  }\n\n  /**\n   * Get list of host belonging to given groups.\n   */\n  getAllHosts(groupFilter) {\n    return this.getGroups(groupFilter)\n    .then(groups => {\n      const groupids = _.map(groups, 'groupid');\n      return this.zabbixAPI.getHosts(groupids);\n    });\n  }\n\n  getHosts(groupFilter?, hostFilter?) {\n    return this.getAllHosts(groupFilter)\n    .then(hosts => findByFilter(hosts, hostFilter));\n  }\n\n  /**\n   * Get list of applications belonging to given groups and hosts.\n   */\n  getAllApps(groupFilter, hostFilter) {\n    return this.getHosts(groupFilter, hostFilter)\n    .then(hosts => {\n      const hostids = _.map(hosts, 'hostid');\n      return this.zabbixAPI.getApps(hostids);\n    });\n  }\n\n  getApps(groupFilter?, hostFilter?, appFilter?): Promise<AppsResponse> {\n    return this.getHosts(groupFilter, hostFilter)\n    .then(hosts => {\n      const hostids = _.map(hosts, 'hostid');\n      if (appFilter) {\n        return this.zabbixAPI.getApps(hostids)\n        .then(apps => filterByQuery(apps, appFilter));\n      } else {\n        const appsResponse: AppsResponse = hostids;\n        appsResponse.hostids = hostids;\n        appsResponse.appFilterEmpty = true;\n        return Promise.resolve(appsResponse);\n      }\n    });\n  }\n\n  getAllItems(groupFilter, hostFilter, appFilter, options: any = {}) {\n    return this.getApps(groupFilter, hostFilter, appFilter)\n    .then(apps => {\n      if (apps.appFilterEmpty) {\n        return this.zabbixAPI.getItems(apps.hostids, undefined, options.itemtype);\n      } else {\n        const appids = _.map(apps, 'applicationid');\n        return this.zabbixAPI.getItems(undefined, appids, options.itemtype);\n      }\n    })\n    .then(items => {\n      if (!options.showDisabledItems) {\n        items = _.filter(items, {'status': '0'});\n      }\n\n      return items;\n    })\n    .then(this.expandUserMacro.bind(this));\n  }\n\n  expandUserMacro(items, isTriggerItem) {\n    const hostids = getHostIds(items);\n    return this.getMacros(hostids)\n    .then(macros => {\n      _.forEach(items, item => {\n        if (utils.containsMacro(isTriggerItem ? item.url : item.name)) {\n          if (isTriggerItem) {\n            item.url = utils.replaceMacro(item, macros, isTriggerItem);\n          } else {\n            item.name = utils.replaceMacro(item, macros);\n          }\n        }\n      });\n      return items;\n    });\n  }\n\n  getItems(groupFilter?, hostFilter?, appFilter?, itemFilter?, options = {}) {\n    return this.getAllItems(groupFilter, hostFilter, appFilter, options)\n    .then(items => filterByQuery(items, itemFilter));\n  }\n\n  getItemValues(groupFilter?, hostFilter?, appFilter?, itemFilter?, options: any = {}) {\n    return this.getItems(groupFilter, hostFilter, appFilter, itemFilter, options).then(items => {\n      let timeRange = [moment().subtract(2, 'h').unix(), moment().unix()];\n      if (options.range) {\n        timeRange = [options.range.from.unix(), options.range.to.unix()];\n      }\n      const [timeFrom, timeTo] = timeRange;\n\n      return this.zabbixAPI.getHistory(items, timeFrom, timeTo).then(history => {\n        if (history) {\n          const values = _.uniq(history.map(v => v.value));\n          return values.map(value => ({ name: value }));\n        } else {\n          return [];\n        }\n      });\n    });\n  }\n\n  getITServices(itServiceFilter) {\n    return this.zabbixAPI.getITService()\n    .then(itServices => findByFilter(itServices, itServiceFilter));\n  }\n\n  getProblems(groupFilter, hostFilter, appFilter, proxyFilter?, options?) {\n    const promises = [\n      this.getGroups(groupFilter),\n      this.getHosts(groupFilter, hostFilter),\n      this.getApps(groupFilter, hostFilter, appFilter)\n    ];\n\n    return Promise.all(promises)\n    .then(results => {\n      const [filteredGroups, filteredHosts, filteredApps] = results;\n      const query: any = {};\n\n      if (appFilter) {\n        query.applicationids = _.flatten(_.map(filteredApps, 'applicationid'));\n      }\n      if (hostFilter) {\n        query.hostids = _.map(filteredHosts, 'hostid');\n      }\n      if (groupFilter) {\n        query.groupids = _.map(filteredGroups, 'groupid');\n      }\n\n      return query;\n    })\n    .then(query => this.zabbixAPI.getProblems(query.groupids, query.hostids, query.applicationids, options))\n    .then(problems => {\n      const triggerids = problems?.map(problem => problem.objectid);\n      return Promise.all([\n        Promise.resolve(problems),\n        this.zabbixAPI.getTriggersByIds(triggerids)\n      ]);\n    })\n    .then(([problems, triggers]) => joinTriggersWithProblems(problems, triggers))\n    .then(triggers => this.filterTriggersByProxy(triggers, proxyFilter))\n    .then(triggers => this.expandUserMacro.bind(this)(triggers, true));\n  }\n\n  getProblemsHistory(groupFilter, hostFilter, appFilter, proxyFilter?, options?): Promise<ProblemDTO[]> {\n    const { valueFromEvent } = options;\n\n    const promises = [\n      this.getGroups(groupFilter),\n      this.getHosts(groupFilter, hostFilter),\n      this.getApps(groupFilter, hostFilter, appFilter)\n    ];\n\n    return Promise.all(promises)\n    .then(results => {\n      const [filteredGroups, filteredHosts, filteredApps] = results;\n      const query: any = {};\n\n      if (appFilter) {\n        query.applicationids = _.flatten(_.map(filteredApps, 'applicationid'));\n      }\n      if (hostFilter) {\n        query.hostids = _.map(filteredHosts, 'hostid');\n      }\n      if (groupFilter) {\n        query.groupids = _.map(filteredGroups, 'groupid');\n      }\n\n      return query;\n    })\n    .then(query => this.zabbixAPI.getEventsHistory(query.groupids, query.hostids, query.applicationids, options))\n    .then(problems => {\n      const triggerids = problems?.map(problem => problem.objectid);\n      return Promise.all([Promise.resolve(problems), this.zabbixAPI.getTriggersByIds(triggerids)]);\n    })\n    .then(([problems, triggers]) => joinTriggersWithEvents(problems, triggers, { valueFromEvent }))\n    .then(triggers => this.filterTriggersByProxy(triggers, proxyFilter))\n    .then(triggers => this.expandUserMacro.bind(this)(triggers, true));\n  }\n\n  filterTriggersByProxy(triggers, proxyFilter) {\n    return this.getFilteredProxies(proxyFilter)\n    .then(proxies => {\n      if (proxyFilter && proxyFilter !== '/.*/' && triggers) {\n        const proxy_ids = proxies.map(proxy => proxy.proxyid);\n        triggers = triggers.filter(trigger => {\n          for (let i = 0; i < trigger.hosts.length; i++) {\n            const host = trigger.hosts[i];\n            if (proxy_ids.includes(host.proxy_hostid)) {\n              return true;\n            }\n          }\n          return false;\n        });\n      }\n      return triggers;\n    });\n  }\n\n  getFilteredProxies(proxyFilter) {\n    return this.zabbixAPI.getProxies()\n    .then(proxies => {\n      proxies.forEach(proxy => proxy.name = proxy.host);\n      return findByFilter(proxies, proxyFilter);\n    });\n  }\n\n  getHistoryTS(items, timeRange, options) {\n    const [timeFrom, timeTo] = timeRange;\n    if (this.enableDirectDBConnection) {\n      return this.getHistoryDB(items, timeFrom, timeTo, options)\n      .then(history => this.dbConnector.handleGrafanaTSResponse(history, items));\n    } else {\n      return this.zabbixAPI.getHistory(items, timeFrom, timeTo)\n      .then(history => responseHandler.handleHistory(history, items));\n    }\n  }\n\n  getTrends(items, timeRange, options) {\n    const [timeFrom, timeTo] = timeRange;\n    if (this.enableDirectDBConnection) {\n      return this.getTrendsDB(items, timeFrom, timeTo, options)\n      .then(history => this.dbConnector.handleGrafanaTSResponse(history, items));\n    } else {\n      const valueType = options.consolidateBy || options.valueType;\n      return this.zabbixAPI.getTrend(items, timeFrom, timeTo)\n      .then(history => responseHandler.handleTrends(history, items, valueType))\n      .then(responseHandler.sortTimeseries); // Sort trend data, issue #202\n    }\n  }\n\n  getHistoryText(items, timeRange, target) {\n    const [timeFrom, timeTo] = timeRange;\n    if (items.length) {\n      return this.zabbixAPI.getHistory(items, timeFrom, timeTo)\n      .then(history => {\n        if (target.resultFormat === 'table') {\n          return responseHandler.handleHistoryAsTable(history, items, target);\n        } else {\n          return responseHandler.handleText(history, items, target);\n        }\n      });\n    } else {\n      return Promise.resolve([]);\n    }\n  }\n\n  getSLA(itservices, timeRange, target, options) {\n    const itServiceIds = _.map(itservices, 'serviceid');\n    return this.zabbixAPI.getSLA(itServiceIds, timeRange, options)\n    .then(slaResponse => {\n      return _.map(itServiceIds, serviceid => {\n        const itservice = _.find(itservices, {'serviceid': serviceid});\n        return responseHandler.handleSLAResponse(itservice, target.slaProperty, slaResponse);\n      });\n    });\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Find group, host, app or item by given name.\n * @param  list list of groups, apps or other\n * @param  name visible name\n * @return      array with finded element or empty array\n */\nfunction findByName(list, name) {\n  const finded = _.find(list, {'name': name});\n  if (finded) {\n    return [finded];\n  } else {\n    return [];\n  }\n}\n\n/**\n * Different hosts can contains applications and items with same name.\n * For this reason use _.filter, which return all elements instead _.find,\n * which return only first finded.\n * @param  {[type]} list list of elements\n * @param  {[type]} name app name\n * @return {[type]}      array with finded element or empty array\n */\nfunction filterByName(list, name) {\n  const finded = _.filter(list, {'name': name});\n  if (finded) {\n    return finded;\n  } else {\n    return [];\n  }\n}\n\nfunction filterByRegex(list, regex) {\n  const filterPattern = utils.buildRegex(regex);\n  return _.filter(list, (zbx_obj) => {\n    return filterPattern.test(zbx_obj.name);\n  });\n}\n\nfunction findByFilter(list, filter) {\n  if (utils.isRegex(filter)) {\n    return filterByRegex(list, filter);\n  } else {\n    return findByName(list, filter);\n  }\n}\n\nfunction filterByQuery(list, filter) {\n  if (utils.isRegex(filter)) {\n    return filterByRegex(list, filter);\n  } else {\n    return filterByName(list, filter);\n  }\n}\n\nfunction getHostIds(items) {\n  const hostIds = _.map(items, item => {\n    return _.map(item.hosts, 'hostid');\n  });\n  return _.uniq(_.flatten(hostIds));\n}\n","import _ from 'lodash';\nimport config from 'grafana/app/core/config';\nimport { contextSrv } from 'grafana/app/core/core';\nimport * as dateMath from 'grafana/app/core/utils/datemath';\nimport * as utils from './utils';\nimport * as migrations from './migrations';\nimport * as metricFunctions from './metricFunctions';\nimport * as c from './constants';\nimport dataProcessor from './dataProcessor';\nimport responseHandler from './responseHandler';\nimport problemsHandler from './problemsHandler';\nimport { Zabbix } from './zabbix/zabbix';\nimport { ZabbixAPIError } from './zabbix/connectors/zabbix_api/zabbixAPICore';\nimport { VariableQueryTypes, ShowProblemTypes } from './types';\n\nexport class ZabbixDatasource {\n  name: string;\n  url: string;\n  basicAuth: any;\n  withCredentials: any;\n\n  username: string;\n  password: string;\n  trends: boolean;\n  trendsFrom: string;\n  trendsRange: string;\n  cacheTTL: any;\n  alertingEnabled: boolean;\n  addThresholds: boolean;\n  alertingMinSeverity: string;\n  disableReadOnlyUsersAck: boolean;\n  enableDirectDBConnection: boolean;\n  dbConnectionDatasourceId: number;\n  dbConnectionDatasourceName: string;\n  dbConnectionRetentionPolicy: string;\n  enableDebugLog: boolean;\n  zabbix: Zabbix;\n\n  replaceTemplateVars: (target: any, scopedVars?: any) => any;\n\n  /** @ngInject */\n  constructor(instanceSettings, private templateSrv, private zabbixAlertingSrv) {\n    this.templateSrv = templateSrv;\n    this.zabbixAlertingSrv = zabbixAlertingSrv;\n\n    this.enableDebugLog = config.buildInfo.env === 'development';\n\n    // Use custom format for template variables\n    this.replaceTemplateVars = _.partial(replaceTemplateVars, this.templateSrv);\n\n    // General data source settings\n    this.name             = instanceSettings.name;\n    this.url              = instanceSettings.url;\n    this.basicAuth        = instanceSettings.basicAuth;\n    this.withCredentials  = instanceSettings.withCredentials;\n\n    const jsonData = migrations.migrateDSConfig(instanceSettings.jsonData);\n\n    // Zabbix API credentials\n    this.username         = jsonData.username;\n    this.password         = jsonData.password;\n\n    // Use trends instead history since specified time\n    this.trends           = jsonData.trends;\n    this.trendsFrom       = jsonData.trendsFrom || '7d';\n    this.trendsRange      = jsonData.trendsRange || '4d';\n\n    // Set cache update interval\n    const ttl = jsonData.cacheTTL || '1h';\n    this.cacheTTL = utils.parseInterval(ttl);\n\n    // Alerting options\n    this.alertingEnabled =     jsonData.alerting;\n    this.addThresholds =       jsonData.addThresholds;\n    this.alertingMinSeverity = jsonData.alertingMinSeverity || c.SEV_WARNING;\n\n    // Other options\n    this.disableReadOnlyUsersAck = jsonData.disableReadOnlyUsersAck;\n\n    // Direct DB Connection options\n    this.enableDirectDBConnection = jsonData.dbConnectionEnable || false;\n    this.dbConnectionDatasourceId = jsonData.dbConnectionDatasourceId;\n    this.dbConnectionDatasourceName = jsonData.dbConnectionDatasourceName;\n    this.dbConnectionRetentionPolicy = jsonData.dbConnectionRetentionPolicy;\n\n    const zabbixOptions = {\n      url: this.url,\n      username: this.username,\n      password: this.password,\n      basicAuth: this.basicAuth,\n      withCredentials: this.withCredentials,\n      cacheTTL: this.cacheTTL,\n      enableDirectDBConnection: this.enableDirectDBConnection,\n      dbConnectionDatasourceId: this.dbConnectionDatasourceId,\n      dbConnectionDatasourceName: this.dbConnectionDatasourceName,\n      dbConnectionRetentionPolicy: this.dbConnectionRetentionPolicy,\n    };\n\n    this.zabbix = new Zabbix(zabbixOptions);\n  }\n\n  ////////////////////////\n  // Datasource methods //\n  ////////////////////////\n\n  /**\n   * Query panel data. Calls for each panel in dashboard.\n   * @param  {Object} options   Contains time range, targets and other info.\n   * @return {Object} Grafana metrics object with timeseries data for each target.\n   */\n  query(options) {\n    // Get alerts for current panel\n    if (this.alertingEnabled) {\n      this.alertQuery(options).then(alert => {\n        this.zabbixAlertingSrv.setPanelAlertState(options.panelId, alert.state);\n\n        this.zabbixAlertingSrv.removeZabbixThreshold(options.panelId);\n        if (this.addThresholds) {\n          _.forEach(alert.thresholds, threshold => {\n            this.zabbixAlertingSrv.setPanelThreshold(options.panelId, threshold);\n          });\n        }\n      });\n    }\n\n    // Create request for each target\n    const promises = _.map(options.targets, t => {\n      // Don't request for hidden targets\n      if (t.hide) {\n        return [];\n      }\n\n      let timeFrom = Math.ceil(dateMath.parse(options.range.from) / 1000);\n      let timeTo = Math.ceil(dateMath.parse(options.range.to) / 1000);\n\n      // Add range variables\n      options.scopedVars = Object.assign({}, options.scopedVars, utils.getRangeScopedVars(options.range));\n\n      // Prevent changes of original object\n      let target = _.cloneDeep(t);\n\n      // Migrate old targets\n      target = migrations.migrate(target);\n      this.replaceTargetVariables(target, options);\n\n      // Apply Time-related functions (timeShift(), etc)\n      const timeFunctions = bindFunctionDefs(target.functions, 'Time');\n      if (timeFunctions.length) {\n        const [time_from, time_to] = utils.sequence(timeFunctions)([timeFrom, timeTo]);\n        timeFrom = time_from;\n        timeTo = time_to;\n      }\n      const timeRange = [timeFrom, timeTo];\n\n      const useTrends = this.isUseTrends(timeRange);\n\n      // Metrics or Text query\n      if (!target.queryType || target.queryType === c.MODE_METRICS || target.queryType === c.MODE_TEXT) {\n        // Don't request undefined targets\n        if (!target.group || !target.host || !target.item) {\n          return [];\n        }\n\n        if (!target.queryType || target.queryType === c.MODE_METRICS) {\n          return this.queryNumericData(target, timeRange, useTrends, options);\n        } else if (target.queryType === c.MODE_TEXT) {\n          return this.queryTextData(target, timeRange);\n        } else {\n          return [];\n        }\n      } else if (target.queryType === c.MODE_ITEMID) {\n        // Item ID query\n        if (!target.itemids) {\n          return [];\n        }\n        return this.queryItemIdData(target, timeRange, useTrends, options);\n      } else if (target.queryType === c.MODE_ITSERVICE) {\n        // IT services query\n        return this.queryITServiceData(target, timeRange, options);\n      } else if (target.queryType === c.MODE_TRIGGERS) {\n        // Triggers query\n        return this.queryTriggersData(target, timeRange);\n      } else if (target.queryType === c.MODE_PROBLEMS) {\n        // Problems query\n        return this.queryProblems(target, timeRange, options);\n      } else {\n        return [];\n      }\n    });\n\n    // Data for panel (all targets)\n    return Promise.all(_.flatten(promises))\n      .then(_.flatten)\n      .then(data => {\n        return { data: data };\n      });\n  }\n\n  /**\n   * Query target data for Metrics\n   */\n  queryNumericData(target, timeRange, useTrends, options) {\n    let queryStart, queryEnd;\n    const getItemOptions = {\n      itemtype: 'num'\n    };\n    return this.zabbix.getItemsFromTarget(target, getItemOptions)\n    .then(items => {\n      queryStart = new Date().getTime();\n      return this.queryNumericDataForItems(items, target, timeRange, useTrends, options);\n    }).then(result => {\n      queryEnd = new Date().getTime();\n      if (this.enableDebugLog) {\n        console.log(`Datasource::Performance Query Time (${this.name}): ${queryEnd - queryStart}`);\n      }\n      return result;\n    });\n  }\n\n  /**\n   * Query history for numeric items\n   */\n  queryNumericDataForItems(items, target, timeRange, useTrends, options) {\n    let getHistoryPromise;\n    options.valueType = this.getTrendValueType(target);\n    options.consolidateBy = getConsolidateBy(target) || options.valueType;\n\n    if (useTrends) {\n      getHistoryPromise = this.zabbix.getTrends(items, timeRange, options);\n    } else {\n      getHistoryPromise = this.zabbix.getHistoryTS(items, timeRange, options);\n    }\n\n    return getHistoryPromise\n    .then(timeseries => this.applyDataProcessingFunctions(timeseries, target))\n    .then(timeseries => downsampleSeries(timeseries, options));\n  }\n\n  getTrendValueType(target) {\n    // Find trendValue() function and get specified trend value\n    const trendFunctions = _.map(metricFunctions.getCategories()['Trends'], 'name');\n    const trendValueFunc = _.find(target.functions, func => {\n      return _.includes(trendFunctions, func.def.name);\n    });\n    return trendValueFunc ? trendValueFunc.params[0] : \"avg\";\n  }\n\n  applyDataProcessingFunctions(timeseries_data, target) {\n    const transformFunctions   = bindFunctionDefs(target.functions, 'Transform');\n    const aggregationFunctions = bindFunctionDefs(target.functions, 'Aggregate');\n    const filterFunctions      = bindFunctionDefs(target.functions, 'Filter');\n    const aliasFunctions       = bindFunctionDefs(target.functions, 'Alias');\n\n    // Apply transformation functions\n    timeseries_data = _.cloneDeep(_.map(timeseries_data, timeseries => {\n      timeseries.datapoints = utils.sequence(transformFunctions)(timeseries.datapoints);\n      return timeseries;\n    }));\n\n    // Apply filter functions\n    if (filterFunctions.length) {\n      timeseries_data = utils.sequence(filterFunctions)(timeseries_data);\n    }\n\n    // Apply aggregations\n    if (aggregationFunctions.length) {\n      let dp = _.map(timeseries_data, 'datapoints');\n      dp = utils.sequence(aggregationFunctions)(dp);\n\n      const aggFuncNames = _.map(metricFunctions.getCategories()['Aggregate'], 'name');\n      const lastAgg = _.findLast(target.functions, func => {\n        return _.includes(aggFuncNames, func.def.name);\n      });\n\n      timeseries_data = [{\n        target: lastAgg.text,\n        datapoints: dp\n      }];\n    }\n\n    // Apply alias functions\n    _.forEach(timeseries_data, utils.sequence(aliasFunctions).bind(this));\n\n    // Apply Time-related functions (timeShift(), etc)\n    // Find timeShift() function and get specified trend value\n    this.applyTimeShiftFunction(timeseries_data, target);\n\n    return timeseries_data;\n  }\n\n  applyTimeShiftFunction(timeseries_data, target) {\n    // Find timeShift() function and get specified interval\n    const timeShiftFunc = _.find(target.functions, (func) => {\n      return func.def.name === 'timeShift';\n    });\n    if (timeShiftFunc) {\n      const shift = timeShiftFunc.params[0];\n      _.forEach(timeseries_data, (series) => {\n        series.datapoints = dataProcessor.unShiftTimeSeries(shift, series.datapoints);\n      });\n    }\n  }\n\n  /**\n   * Query target data for Text\n   */\n  queryTextData(target, timeRange) {\n    const options = {\n      itemtype: 'text'\n    };\n    return this.zabbix.getItemsFromTarget(target, options)\n    .then(items => {\n      return this.zabbix.getHistoryText(items, timeRange, target);\n    });\n  }\n\n  /**\n   * Query target data for Item ID\n   */\n  queryItemIdData(target, timeRange, useTrends, options) {\n    let itemids = target.itemids;\n    itemids = this.templateSrv.replace(itemids, options.scopedVars, zabbixItemIdsTemplateFormat);\n    itemids = _.map(itemids.split(','), itemid => itemid.trim());\n\n    if (!itemids) {\n      return [];\n    }\n\n    return this.zabbix.getItemsByIDs(itemids)\n    .then(items => {\n      return this.queryNumericDataForItems(items, target, timeRange, useTrends, options);\n    });\n  }\n\n  /**\n   * Query target data for IT Services\n   */\n  queryITServiceData(target, timeRange, options) {\n    // Don't show undefined and hidden targets\n    if (target.hide || (!target.itservice && !target.itServiceFilter) || !target.slaProperty) {\n      return [];\n    }\n\n    let itServiceFilter;\n    options.isOldVersion = target.itservice && !target.itServiceFilter;\n\n    if (options.isOldVersion) {\n      // Backward compatibility\n      itServiceFilter = '/.*/';\n    } else {\n      itServiceFilter = this.replaceTemplateVars(target.itServiceFilter, options.scopedVars);\n    }\n\n    options.slaInterval = target.slaInterval;\n\n    return this.zabbix.getITServices(itServiceFilter)\n    .then(itservices => {\n      if (options.isOldVersion) {\n        itservices = _.filter(itservices, {'serviceid': target.itservice?.serviceid});\n      }\n      return this.zabbix.getSLA(itservices, timeRange, target, options);})\n    .then(itservicesdp => this.applyDataProcessingFunctions(itservicesdp, target));\n  }\n\n  queryTriggersData(target, timeRange) {\n    const [timeFrom, timeTo] = timeRange;\n    return this.zabbix.getHostsFromTarget(target)\n    .then(results => {\n      const [hosts, apps] = results;\n      if (hosts.length) {\n        const hostids = _.map(hosts, 'hostid');\n        const appids = _.map(apps, 'applicationid');\n        const options = {\n          minSeverity: target.triggers.minSeverity,\n          acknowledged: target.triggers.acknowledged,\n          count: target.triggers.count,\n          timeFrom: timeFrom,\n          timeTo: timeTo\n        };\n        const groupFilter = target.group.filter;\n        return Promise.all([\n          this.zabbix.getHostAlerts(hostids, appids, options),\n          this.zabbix.getGroups(groupFilter)\n        ])\n        .then(([triggers, groups]) => {\n          return responseHandler.handleTriggersResponse(triggers, groups, timeRange);\n        });\n      } else {\n        return Promise.resolve([]);\n      }\n    });\n  }\n\n  queryProblems(target, timeRange, options) {\n    const [timeFrom, timeTo] = timeRange;\n    const userIsEditor = contextSrv.isEditor || contextSrv.isGrafanaAdmin;\n\n    let proxies;\n    let showAckButton = true;\n\n    const showProblems = target.showProblems || ShowProblemTypes.Problems;\n    const showProxy = target.options.hostProxy;\n\n    const getProxiesPromise = showProxy ? this.zabbix.getProxies() : () => [];\n    showAckButton = !this.disableReadOnlyUsersAck || userIsEditor;\n\n    // Replace template variables\n    const groupFilter = this.replaceTemplateVars(target.group?.filter, options.scopedVars);\n    const hostFilter = this.replaceTemplateVars(target.host?.filter, options.scopedVars);\n    const appFilter = this.replaceTemplateVars(target.application?.filter, options.scopedVars);\n    const proxyFilter = this.replaceTemplateVars(target.proxy?.filter, options.scopedVars);\n\n    const triggerFilter = this.replaceTemplateVars(target.trigger?.filter, options.scopedVars);\n    const tagsFilter = this.replaceTemplateVars(target.tags?.filter, options.scopedVars);\n\n    const replacedTarget = {\n      ...target,\n      trigger: { filter: triggerFilter },\n      tags: { filter: tagsFilter },\n    };\n\n    const problemsOptions: any = {\n      recent: showProblems === ShowProblemTypes.Recent,\n      minSeverity: target.options?.minSeverity,\n      limit: target.options?.limit,\n    };\n\n    if (target.options?.acknowledged === 0 || target.options?.acknowledged === 1) {\n      problemsOptions.acknowledged = target.options?.acknowledged ? true : false;\n    }\n\n    if (target.options?.minSeverity) {\n      const severities = [0, 1, 2, 3, 4, 5].filter(v => v >= target.options?.minSeverity);\n      problemsOptions.severities = severities;\n    }\n\n    if (showProblems === ShowProblemTypes.History) {\n      problemsOptions.timeFrom = timeFrom;\n      problemsOptions.timeTo = timeTo;\n    }\n\n    const getProblemsPromise = showProblems === ShowProblemTypes.History ?\n      this.zabbix.getProblemsHistory(groupFilter, hostFilter, appFilter, proxyFilter, problemsOptions) :\n      this.zabbix.getProblems(groupFilter, hostFilter, appFilter, proxyFilter, problemsOptions);\n\n    const problemsPromises = Promise.all([\n      getProblemsPromise,\n      getProxiesPromise\n    ])\n    .then(([problems, sourceProxies]) => {\n      proxies = _.keyBy(sourceProxies, 'proxyid');\n      return problems;\n    })\n    .then(problems => problemsHandler.setMaintenanceStatus(problems))\n    .then(problems => problemsHandler.setAckButtonStatus(problems, showAckButton))\n    .then(problems => problemsHandler.filterTriggersPre(problems, replacedTarget))\n    .then(problems => problemsHandler.addTriggerDataSource(problems, target))\n    .then(problems => problemsHandler.addTriggerHostProxy(problems, proxies));\n\n    return problemsPromises.then(problems => {\n      const problemsDataFrame = problemsHandler.toDataFrame(problems);\n      return problemsDataFrame;\n    });\n  }\n\n  /**\n   * Test connection to Zabbix API and external history DB.\n   */\n  testDatasource() {\n    return this.zabbix.testDataSource()\n    .then(result => {\n      const { zabbixVersion, dbConnectorStatus } = result;\n      let message = `Zabbix API version: ${zabbixVersion}`;\n      if (dbConnectorStatus) {\n        message += `, DB connector type: ${dbConnectorStatus.dsType}`;\n      }\n      return {\n        status: \"success\",\n        title: \"Success\",\n        message: message\n      };\n    })\n    .catch(error => {\n      if (error instanceof ZabbixAPIError) {\n        return {\n          status: \"error\",\n          title: error.message,\n          message: error.message\n        };\n      } else if (error.data && error.data.message) {\n        return {\n          status: \"error\",\n          title: \"Connection failed\",\n          message: \"Connection failed: \" + error.data.message\n        };\n      } else if (typeof(error) === 'string') {\n        return {\n          status: \"error\",\n          title: \"Connection failed\",\n          message: \"Connection failed: \" + error\n        };\n      } else {\n        console.log(error);\n        return {\n          status: \"error\",\n          title: \"Connection failed\",\n          message: \"Could not connect to given url\"\n        };\n      }\n    });\n  }\n\n  ////////////////\n  // Templating //\n  ////////////////\n\n  /**\n   * Find metrics from templated request.\n   *\n   * @param  {string} query Query from Templating\n   * @return {string}       Metric name - group, host, app or item or list\n   *                        of metrics in \"{metric1,metcic2,...,metricN}\" format.\n   */\n  metricFindQuery(query, options) {\n    let resultPromise;\n    let queryModel = _.cloneDeep(query);\n\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    if (typeof query === 'string') {\n      // Backward compatibility\n      queryModel = utils.parseLegacyVariableQuery(query);\n    }\n\n    for (const prop of ['group', 'host', 'application', 'item']) {\n      queryModel[prop] = this.replaceTemplateVars(queryModel[prop], {});\n    }\n\n    const { group, host, application, item } = queryModel;\n\n    switch (queryModel.queryType) {\n      case VariableQueryTypes.Group:\n        resultPromise = this.zabbix.getGroups(queryModel.group);\n        break;\n      case VariableQueryTypes.Host:\n        resultPromise = this.zabbix.getHosts(queryModel.group, queryModel.host);\n        break;\n      case VariableQueryTypes.Application:\n        resultPromise = this.zabbix.getApps(queryModel.group, queryModel.host, queryModel.application);\n        break;\n      case VariableQueryTypes.Item:\n        resultPromise = this.zabbix.getItems(queryModel.group, queryModel.host, queryModel.application, queryModel.item);\n        break;\n      case VariableQueryTypes.ItemValues:\n        const range = options?.range;\n        resultPromise = this.zabbix.getItemValues(group, host, application, item, { range });\n        break;\n      default:\n        resultPromise = Promise.resolve([]);\n        break;\n    }\n\n    return resultPromise.then(metrics => {\n      return _.map(metrics, formatMetric);\n    });\n  }\n\n  /////////////////\n  // Annotations //\n  /////////////////\n\n  annotationQuery(options) {\n    const timeRange = options.range || options.rangeRaw;\n    const timeFrom = Math.ceil(dateMath.parse(timeRange.from) / 1000);\n    const timeTo = Math.ceil(dateMath.parse(timeRange.to) / 1000);\n    const annotation = options.annotation;\n\n    // Show all triggers\n    const problemsOptions: any = {\n      value: annotation.showOkEvents ? ['0', '1'] : '1',\n      valueFromEvent: true,\n      timeFrom,\n      timeTo,\n    };\n\n    if (annotation.minseverity) {\n      const severities = [0, 1, 2, 3, 4, 5].filter(v => v >= Number(annotation.minseverity));\n      problemsOptions.severities = severities;\n    }\n\n    const groupFilter = this.replaceTemplateVars(annotation.group, {});\n    const hostFilter = this.replaceTemplateVars(annotation.host, {});\n    const appFilter = this.replaceTemplateVars(annotation.application, {});\n    const proxyFilter = undefined;\n\n    return this.zabbix.getProblemsHistory(groupFilter, hostFilter, appFilter, proxyFilter, problemsOptions)\n    .then(problems => {\n      // Filter triggers by description\n      const problemName = this.replaceTemplateVars(annotation.trigger, {});\n      if (utils.isRegex(problemName)) {\n        problems = _.filter(problems, p => {\n          return utils.buildRegex(problemName).test(p.description);\n        });\n      } else if (problemName) {\n        problems = _.filter(problems, p => {\n          return p.description === problemName;\n        });\n      }\n\n      // Hide acknowledged events if option enabled\n      if (annotation.hideAcknowledged) {\n        problems = _.filter(problems, p => {\n          return !p.acknowledges?.length;\n        });\n      }\n\n      return _.map(problems, p => {\n        const formattedAcknowledges = utils.formatAcknowledges(p.acknowledges);\n\n        let annotationTags: string[] = [];\n        if (annotation.showHostname) {\n          annotationTags = _.map(p.hosts, 'name');\n        }\n\n        return {\n          title: p.value === '1' ? 'Problem' : 'OK',\n          time: p.timestamp * 1000,\n          annotation: annotation,\n          text: p.name + formattedAcknowledges,\n          tags: annotationTags,\n        };\n      });\n    });\n  }\n\n  /**\n   * Get triggers and its details for panel's targets\n   * Returns alert state ('ok' if no fired triggers, or 'alerting' if at least 1 trigger is fired)\n   * or empty object if no related triggers are finded.\n   */\n  alertQuery(options) {\n    const enabled_targets = filterEnabledTargets(options.targets);\n    const getPanelItems = _.map(enabled_targets, t => {\n      let target = _.cloneDeep(t);\n      target = migrations.migrate(target);\n      this.replaceTargetVariables(target, options);\n      return this.zabbix.getItemsFromTarget(target, {itemtype: 'num'});\n    });\n\n    return Promise.all(getPanelItems)\n    .then(results => {\n      const items = _.flatten(results);\n      const itemids = _.map(items, 'itemid');\n\n      if (itemids.length === 0) {\n        return [];\n      }\n      return this.zabbix.getAlerts(itemids);\n    })\n    .then(triggers => {\n      triggers = _.filter(triggers, trigger => {\n        return trigger.priority >= this.alertingMinSeverity;\n      });\n\n      if (!triggers || triggers.length === 0) {\n        return {};\n      }\n\n      let state = 'ok';\n\n      const firedTriggers = _.filter(triggers, {value: '1'});\n      if (firedTriggers.length) {\n        state = 'alerting';\n      }\n\n      const thresholds = _.map(triggers, trigger => {\n        return getTriggerThreshold(trigger.expression);\n      });\n\n      return {\n        panelId: options.panelId,\n        state: state,\n        thresholds: thresholds\n      };\n    });\n  }\n\n  // Replace template variables\n  replaceTargetVariables(target, options) {\n    const parts = ['group', 'host', 'application', 'item'];\n    _.forEach(parts, p => {\n      if (target[p] && target[p].filter) {\n        target[p].filter = this.replaceTemplateVars(target[p].filter, options.scopedVars);\n      }\n    });\n    target.textFilter = this.replaceTemplateVars(target.textFilter, options.scopedVars);\n\n    _.forEach(target.functions, func => {\n      func.params = _.map(func.params, param => {\n        if (typeof param === 'number') {\n          return +this.templateSrv.replace(param.toString(), options.scopedVars);\n        } else {\n          return this.templateSrv.replace(param, options.scopedVars);\n        }\n      });\n    });\n  }\n\n  isUseTrends(timeRange) {\n    const [timeFrom, timeTo] = timeRange;\n    const useTrendsFrom = Math.ceil(dateMath.parse('now-' + this.trendsFrom) / 1000);\n    const useTrendsRange = Math.ceil(utils.parseInterval(this.trendsRange) / 1000);\n    const useTrends = this.trends && (\n      (timeFrom < useTrendsFrom) ||\n      (timeTo - timeFrom > useTrendsRange)\n    );\n    return useTrends;\n  }\n}\n\nfunction bindFunctionDefs(functionDefs, category) {\n  const aggregationFunctions = _.map(metricFunctions.getCategories()[category], 'name');\n  const aggFuncDefs = _.filter(functionDefs, func => {\n    return _.includes(aggregationFunctions, func.def.name);\n  });\n\n  return _.map(aggFuncDefs, func => {\n    const funcInstance = metricFunctions.createFuncInstance(func.def, func.params);\n    return funcInstance.bindFunction(dataProcessor.metricFunctions);\n  });\n}\n\nfunction getConsolidateBy(target) {\n  let consolidateBy;\n  const funcDef = _.find(target.functions, func => {\n    return func.def.name === 'consolidateBy';\n  });\n  if (funcDef && funcDef.params && funcDef.params.length) {\n    consolidateBy = funcDef.params[0];\n  }\n  return consolidateBy;\n}\n\nfunction downsampleSeries(timeseries_data, options) {\n  const defaultAgg = dataProcessor.aggregationFunctions['avg'];\n  const consolidateByFunc = dataProcessor.aggregationFunctions[options.consolidateBy] || defaultAgg;\n  return _.map(timeseries_data, timeseries => {\n    if (timeseries.datapoints.length > options.maxDataPoints) {\n      timeseries.datapoints = dataProcessor\n        .groupBy(options.interval, consolidateByFunc, timeseries.datapoints);\n    }\n    return timeseries;\n  });\n}\n\nfunction formatMetric(metricObj) {\n  return {\n    text: metricObj.name,\n    expandable: false\n  };\n}\n\n/**\n * Custom formatter for template variables.\n * Default Grafana \"regex\" formatter returns\n * value1|value2\n * This formatter returns\n * (value1|value2)\n * This format needed for using in complex regex with\n * template variables, for example\n * /CPU $cpu_item.*time/ where $cpu_item is system,user,iowait\n */\nexport function zabbixTemplateFormat(value) {\n  if (typeof value === 'string') {\n    return utils.escapeRegex(value);\n  }\n\n  const escapedValues = _.map(value, utils.escapeRegex);\n  return '(' + escapedValues.join('|') + ')';\n}\n\nfunction zabbixItemIdsTemplateFormat(value) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  return value.join(',');\n}\n\n/**\n * If template variables are used in request, replace it using regex format\n * and wrap with '/' for proper multi-value work. Example:\n * $variable selected as a, b, c\n * We use filter $variable\n * $variable    -> a|b|c    -> /a|b|c/\n * /$variable/  -> /a|b|c/  -> /a|b|c/\n */\nfunction replaceTemplateVars(templateSrv, target, scopedVars) {\n  let replacedTarget = templateSrv.replace(target, scopedVars, zabbixTemplateFormat);\n  if (target !== replacedTarget && !utils.isRegex(replacedTarget)) {\n    replacedTarget = '/^' + replacedTarget + '$/';\n  }\n  return replacedTarget;\n}\n\nfunction filterEnabledTargets(targets) {\n  return _.filter(targets, target => {\n    return !(target.hide || !target.group || !target.host || !target.item);\n  });\n}\n\nfunction getTriggerThreshold(expression) {\n  const thresholdPattern = /.*[<>=]{1,2}([\\d\\.]+)/;\n  const finded_thresholds = expression.match(thresholdPattern);\n  if (finded_thresholds && finded_thresholds.length >= 2) {\n    let threshold = finded_thresholds[1];\n    threshold = Number(threshold);\n    return threshold;\n  } else {\n    return null;\n  }\n}\n","import { QueryCtrl } from 'grafana/app/plugins/sdk';\nimport _ from 'lodash';\nimport * as c from './constants';\nimport * as utils from './utils';\nimport * as metricFunctions from './metricFunctions';\nimport * as migrations from './migrations';\nimport { ShowProblemTypes } from './types';\n\nfunction getTargetDefaults() {\n  return {\n    queryType: c.MODE_METRICS,\n    group: { 'filter': \"\" },\n    host: { 'filter': \"\" },\n    application: { 'filter': \"\" },\n    item: { 'filter': \"\" },\n    functions: [],\n    triggers: {\n      'count': true,\n      'minSeverity': 3,\n      'acknowledged': 2\n    },\n    trigger: {filter: \"\"},\n    tags: {filter: \"\"},\n    proxy: {filter: \"\"},\n    options: {\n      showDisabledItems: false,\n      skipEmptyValues: false,\n    },\n    table: {\n      'skipEmptyValues': false\n    },\n  };\n}\n\nfunction getSLATargetDefaults() {\n  return {\n    slaProperty: { name: \"SLA\", property: \"sla\" },\n    slaInterval: 'none',\n  };\n}\n\nfunction getProblemsTargetDefaults() {\n  return {\n    showProblems: ShowProblemTypes.Problems,\n    options: {\n      minSeverity: 0,\n      sortProblems: 'default',\n      acknowledged: 2,\n      hostsInMaintenance: false,\n      hostProxy: false,\n      limit: c.DEFAULT_ZABBIX_PROBLEMS_LIMIT,\n    },\n  };\n}\n\nfunction getSeverityOptions() {\n  return c.TRIGGER_SEVERITY;\n}\n\nexport class ZabbixQueryController extends QueryCtrl {\n\n  /** @ngInject */\n  constructor($scope, $injector, $rootScope, $sce, templateSrv) {\n    super($scope, $injector);\n    this.zabbix = this.datasource.zabbix;\n\n    // Use custom format for template variables\n    this.replaceTemplateVars = this.datasource.replaceTemplateVars;\n    this.templateSrv = templateSrv;\n\n    this.editorModes = [\n      {value: 'num',       text: 'Metrics',     queryType: c.MODE_METRICS},\n      {value: 'text',      text: 'Text',        queryType: c.MODE_TEXT},\n      {value: 'itservice', text: 'IT Services', queryType: c.MODE_ITSERVICE},\n      {value: 'itemid',    text: 'Item ID',     queryType: c.MODE_ITEMID},\n      {value: 'triggers',  text: 'Triggers',    queryType: c.MODE_TRIGGERS},\n      {value: 'problems',  text: 'Problems',    queryType: c.MODE_PROBLEMS},\n    ];\n\n    this.$scope.editorMode = {\n      METRICS: c.MODE_METRICS,\n      TEXT: c.MODE_TEXT,\n      ITSERVICE: c.MODE_ITSERVICE,\n      ITEMID: c.MODE_ITEMID,\n      TRIGGERS: c.MODE_TRIGGERS,\n      PROBLEMS: c.MODE_PROBLEMS,\n    };\n\n    this.slaPropertyList = [\n      {name: \"Status\", property: \"status\"},\n      {name: \"SLA\", property: \"sla\"},\n      {name: \"OK time\", property: \"okTime\"},\n      {name: \"Problem time\", property: \"problemTime\"},\n      {name: \"Down time\", property: \"downtimeTime\"}\n    ];\n\n    this.slaIntervals = [\n      { text: 'No interval', value: 'none' },\n      { text: 'Auto', value: 'auto' },\n      { text: '1 hour', value: '1h' },\n      { text: '12 hours', value: '12h' },\n      { text: '24 hours', value: '1d' },\n      { text: '1 week', value: '1w' },\n      { text: '1 month', value: '1M' },\n    ];\n\n    this.ackFilters = [\n      {text: 'all triggers', value: 2},\n      {text: 'unacknowledged', value: 0},\n      {text: 'acknowledged', value: 1},\n    ];\n\n    this.problemAckFilters = [\n      'all triggers',\n      'unacknowledged',\n      'acknowledged'\n    ];\n\n    this.sortByFields = [\n      { text: 'Default', value: 'default' },\n      { text: 'Last change', value: 'lastchange' },\n      { text: 'Severity',    value: 'priority' },\n    ];\n\n    this.showEventsFields = [\n      { text: 'All',      value: [0,1] },\n      { text: 'OK',       value: [0] },\n      { text: 'Problems', value: 1 }\n    ];\n\n    this.showProblemsOptions = [\n      { text: 'Problems', value: 'problems' },\n      { text: 'Recent problems', value: 'recent' },\n      { text: 'History', value: 'history' },\n    ];\n\n    this.resultFormats = [{ text: 'Time series', value: 'time_series' }, { text: 'Table', value: 'table' }];\n\n    this.severityOptions = getSeverityOptions();\n\n    // Map functions for bs-typeahead\n    this.getGroupNames = _.bind(this.getMetricNames, this, 'groupList');\n    this.getHostNames = _.bind(this.getMetricNames, this, 'hostList', true);\n    this.getApplicationNames = _.bind(this.getMetricNames, this, 'appList');\n    this.getItemNames = _.bind(this.getMetricNames, this, 'itemList');\n    this.getITServices = _.bind(this.getMetricNames, this, 'itServiceList');\n    this.getProxyNames = _.bind(this.getMetricNames, this, 'proxyList');\n    this.getVariables = _.bind(this.getTemplateVariables, this);\n\n    // Update metric suggestion when template variable was changed\n    $rootScope.$on('template-variable-value-updated', () => this.onVariableChange());\n\n    // Update metrics when item selected from dropdown\n    $scope.$on('typeahead-updated', () => {\n      this.onTargetBlur();\n    });\n\n    this.init = function() {\n      var target = this.target;\n\n      // Migrate old targets\n      target = migrations.migrate(target);\n\n      var scopeDefaults = {\n        metric: {},\n        oldTarget: _.cloneDeep(this.target),\n        queryOptionsText: this.renderQueryOptionsText()\n      };\n      _.defaults(this, scopeDefaults);\n\n      // Load default values\n      const targetDefaults = getTargetDefaults();\n      _.defaultsDeep(target, targetDefaults);\n\n      if (this.panel.type === c.ZABBIX_PROBLEMS_PANEL_ID) {\n        target.queryType = c.MODE_PROBLEMS;\n      }\n\n      // Create function instances from saved JSON\n      target.functions = _.map(target.functions, function(func) {\n        return metricFunctions.createFuncInstance(func.def, func.params);\n      });\n\n      if (target.queryType === c.MODE_ITSERVICE) {\n        _.defaultsDeep(target, getSLATargetDefaults());\n      }\n\n      if (target.queryType === c.MODE_PROBLEMS) {\n        _.defaultsDeep(target, getProblemsTargetDefaults());\n      }\n\n      if (target.queryType === c.MODE_METRICS ||\n          target.queryType === c.MODE_TEXT ||\n          target.queryType === c.MODE_TRIGGERS ||\n          target.queryType === c.MODE_PROBLEMS) {\n        this.initFilters();\n      } else if (target.queryType === c.MODE_ITSERVICE) {\n        this.suggestITServices();\n      }\n    };\n\n    this.init();\n    this.queryOptionsText = this.renderQueryOptionsText();\n  }\n\n  initFilters() {\n    let itemtype = _.find(this.editorModes, {'queryType': this.target.queryType});\n    itemtype = itemtype ? itemtype.value : null;\n    const promises = [\n      this.suggestGroups(),\n      this.suggestHosts(),\n      this.suggestApps(),\n      this.suggestItems(itemtype),\n    ];\n\n    if (this.target.queryType === c.MODE_PROBLEMS) {\n      promises.push(this.suggestProxies());\n    }\n\n    return Promise.all(promises);\n  }\n\n  // Get list of metric names for bs-typeahead directive\n  getMetricNames(metricList, addAllValue) {\n    let metrics = _.uniq(_.map(this.metric[metricList], 'name'));\n\n    // Add template variables\n    _.forEach(this.templateSrv.variables, variable => {\n      metrics.unshift('$' + variable.name);\n    });\n\n    if (addAllValue) {\n      metrics.unshift('/.*/');\n    }\n\n    return metrics;\n  }\n\n  getTemplateVariables() {\n    return _.map(this.templateSrv.variables, variable => {\n      return '$' + variable.name;\n    });\n  }\n\n  suggestGroups() {\n    return this.zabbix.getAllGroups()\n    .then(groups => {\n      this.metric.groupList = groups;\n      return groups;\n    });\n  }\n\n  suggestHosts() {\n    let groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    return this.zabbix.getAllHosts(groupFilter)\n    .then(hosts => {\n      this.metric.hostList = hosts;\n      return hosts;\n    });\n  }\n\n  suggestApps() {\n    let groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    let hostFilter = this.replaceTemplateVars(this.target.host.filter);\n    return this.zabbix.getAllApps(groupFilter, hostFilter)\n    .then(apps => {\n      this.metric.appList = apps;\n      return apps;\n    });\n  }\n\n  suggestItems(itemtype = 'num') {\n    let groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    let hostFilter = this.replaceTemplateVars(this.target.host.filter);\n    let appFilter = this.replaceTemplateVars(this.target.application.filter);\n    let options = {\n      itemtype: itemtype,\n      showDisabledItems: this.target.options.showDisabledItems\n    };\n\n    return this.zabbix\n    .getAllItems(groupFilter, hostFilter, appFilter, options)\n    .then(items => {\n      this.metric.itemList = items;\n      return items;\n    });\n  }\n\n  suggestITServices() {\n    return this.zabbix.getITService()\n    .then(itservices => {\n      this.metric.itServiceList = itservices;\n      return itservices;\n    });\n  }\n\n  suggestProxies() {\n    return this.zabbix.getProxies()\n    .then(response => {\n      const proxies = _.map(response, 'host');\n      this.metric.proxyList = proxies;\n      return proxies;\n    });\n  }\n\n  isRegex(str) {\n    return utils.isRegex(str);\n  }\n\n  isVariable(str) {\n    return utils.isTemplateVariable(str, this.templateSrv.variables);\n  }\n\n  onTargetBlur() {\n    var newTarget = _.cloneDeep(this.target);\n    if (!_.isEqual(this.oldTarget, this.target)) {\n      this.oldTarget = newTarget;\n      this.targetChanged();\n    }\n  }\n\n  onVariableChange() {\n    if (this.isContainsVariables()) {\n      this.targetChanged();\n    }\n  }\n\n  /**\n   * Check query for template variables\n   */\n  isContainsVariables() {\n    return _.some(['group', 'host', 'application'], field => {\n      if (this.target[field] && this.target[field].filter) {\n        return utils.isTemplateVariable(this.target[field].filter, this.templateSrv.variables);\n      } else {\n        return false;\n      }\n    });\n  }\n\n  parseTarget() {\n    // Parse target\n  }\n\n  // Validate target and set validation info\n  validateTarget() {\n    // validate\n  }\n\n  targetChanged() {\n    this.initFilters();\n    this.parseTarget();\n    this.panelCtrl.refresh();\n  }\n\n  addFunction(funcDef) {\n    var newFunc = metricFunctions.createFuncInstance(funcDef);\n    newFunc.added = true;\n    this.target.functions.push(newFunc);\n\n    this.moveAliasFuncLast();\n\n    if (newFunc.params.length && newFunc.added ||\n        newFunc.def.params.length === 0) {\n      this.targetChanged();\n    }\n  }\n\n  removeFunction(func) {\n    this.target.functions = _.without(this.target.functions, func);\n    this.targetChanged();\n  }\n\n  moveFunction(func, offset) {\n    const index = this.target.functions.indexOf(func);\n    _.move(this.target.functions, index, index + offset);\n    this.targetChanged();\n  }\n\n  moveAliasFuncLast() {\n    var aliasFunc = _.find(this.target.functions, func => {\n      return func.def.category === 'Alias';\n    });\n\n    if (aliasFunc) {\n      this.target.functions = _.without(this.target.functions, aliasFunc);\n      this.target.functions.push(aliasFunc);\n    }\n  }\n\n  toggleQueryOptions() {\n    this.showQueryOptions = !this.showQueryOptions;\n  }\n\n  onQueryOptionChange() {\n    this.queryOptionsText = this.renderQueryOptionsText();\n    this.onTargetBlur();\n  }\n\n  renderQueryOptionsText() {\n    const metricOptionsMap = {\n      showDisabledItems: \"Show disabled items\",\n    };\n\n    const problemsOptionsMap = {\n      sortProblems: \"Sort problems\",\n      acknowledged: \"Acknowledged\",\n      skipEmptyValues: \"Skip empty values\",\n      hostsInMaintenance: \"Show hosts in maintenance\",\n      limit: \"Limit problems\",\n      hostProxy: \"Show proxy\",\n    };\n\n    let optionsMap = {};\n\n    if (this.target.queryType === c.MODE_METRICS) {\n      optionsMap = metricOptionsMap;\n    } else if (this.target.queryType === c.MODE_PROBLEMS || this.target.queryType === c.MODE_TRIGGERS) {\n      optionsMap = problemsOptionsMap;\n    }\n\n    const options = [];\n    _.forOwn(this.target.options, (value, key) => {\n      if (value && optionsMap[key]) {\n        if (value === true) {\n          // Show only option name (if enabled) for boolean options\n          options.push(optionsMap[key]);\n        } else {\n          // Show \"option = value\" for another options\n          let optionValue = value;\n          if (value && value.text) {\n            optionValue = value.text;\n          } else if (value && value.value) {\n            optionValue = value.value;\n          }\n          options.push(optionsMap[key] + \" = \" + optionValue);\n        }\n      }\n    });\n    return \"Options: \" + options.join(', ');\n  }\n\n  /**\n   * Switch query editor to specified mode.\n   * Modes:\n   *  0 - items\n   *  1 - IT services\n   *  2 - Text metrics\n   */\n  switchEditorMode(mode) {\n    this.target.queryType = mode;\n    this.queryOptionsText = this.renderQueryOptionsText();\n    this.init();\n    this.targetChanged();\n  }\n}\n","import _ from 'lodash';\nimport { getDataSourceSrv } from '@grafana/runtime';\nimport { migrateDSConfig } from './migrations';\n\nconst SUPPORTED_SQL_DS = ['mysql', 'postgres', 'influxdb'];\n\nconst defaultConfig = {\n  trends: false,\n  dbConnectionEnable: false,\n  dbConnectionDatasourceId: null,\n  alerting: false,\n  addThresholds: false,\n  alertingMinSeverity: 3,\n  disableReadOnlyUsersAck: false,\n};\n\nexport class ZabbixDSConfigController {\n\n  /** @ngInject */\n  constructor() {\n    this.current.jsonData = migrateDSConfig(this.current.jsonData);\n    _.defaults(this.current.jsonData, defaultConfig);\n\n    this.dbConnectionDatasourceId = this.current.jsonData.dbConnectionDatasourceId;\n    this.dbDataSources = this.getSupportedDBDataSources();\n    if (!this.dbConnectionDatasourceId) {\n      this.loadCurrentDBDatasource();\n    }\n  }\n\n  getSupportedDBDataSources() {\n    let datasources = getDataSourceSrv().getAll();\n    return _.filter(datasources, ds => {\n      return _.includes(SUPPORTED_SQL_DS, ds.type);\n    });\n  }\n\n  getCurrentDatasourceType() {\n    const dsId = this.dbConnectionDatasourceId;\n    const currentDs = _.find(this.dbDataSources, { 'id': dsId });\n    return currentDs ? currentDs.type : null;\n  }\n\n  loadCurrentDBDatasource() {\n    const dsName= this.current.jsonData.dbConnectionDatasourceName;\n    getDataSourceSrv().loadDatasource(dsName)\n    .then(ds => {\n      if (ds) {\n        this.dbConnectionDatasourceId = ds.id;\n      }\n    });\n  }\n\n  onDBConnectionDatasourceChange() {\n    this.current.jsonData.dbConnectionDatasourceId = this.dbConnectionDatasourceId;\n  }\n}\n","import React, { FC } from 'react';\nimport { css, cx } from 'emotion';\nimport { EventsWithValidation, ValidationEvents, useTheme } from '@grafana/ui';\nimport { GrafanaTheme } from '@grafana/data';\nimport { isRegex, variableRegex } from '../utils';\n\nimport * as grafanaUi from '@grafana/ui';\nconst Input = (grafanaUi as any).LegacyForms?.Input || (grafanaUi as any).Input;\n\nconst variablePattern = RegExp(`^${variableRegex.source}`);\n\nconst getStyles = (theme: GrafanaTheme) => ({\n  inputRegex: css`\n    color: ${theme.colors.orange || (theme as any).palette.orange}\n  `,\n  inputVariable: css`\n    color: ${theme.colors.variable || (theme as any).palette.variable}\n  `,\n});\n\nconst zabbixInputValidationEvents: ValidationEvents = {\n  [EventsWithValidation.onBlur]: [\n    {\n      rule: value => {\n        if (!value) {\n          return true;\n        }\n        if (value.length > 1 && value[0] === '/') {\n          if (value[value.length - 1] !== '/') {\n            return false;\n          }\n        }\n        return true;\n      },\n      errorMessage: 'Not a valid regex',\n    },\n    {\n      rule: value => {\n        if (value === '*') {\n          return false;\n        }\n        return true;\n      },\n      errorMessage: 'Wildcards not supported. Use /.*/ instead',\n    },\n  ],\n};\n\nexport const ZabbixInput: FC<any> = ({ value, ref, validationEvents, ...restProps }) => {\n  const theme = useTheme();\n  const styles = getStyles(theme);\n\n  let inputClass = styles.inputRegex;\n  if (variablePattern.test(value as string)) {\n    inputClass = styles.inputVariable;\n  } else if (isRegex(value)) {\n    inputClass = styles.inputRegex;\n  }\n\n  return (\n    <Input\n      className={inputClass}\n      value={value}\n      validationEvents={zabbixInputValidationEvents}\n      {...restProps}\n    />\n  );\n};\n","import React, { PureComponent } from 'react';\nimport { parseLegacyVariableQuery } from '../utils';\nimport { SelectableValue } from '@grafana/data';\nimport { VariableQuery, VariableQueryTypes, VariableQueryProps, VariableQueryData } from '../types';\nimport { ZabbixInput } from './ZabbixInput';\n\n// FormLabel was renamed to InlineFormLabel in Grafana 7.0\nimport * as grafanaUi from '@grafana/ui';\nconst FormLabel = grafanaUi.FormLabel || (grafanaUi as any).InlineFormLabel;\nconst Select = (grafanaUi as any).LegacyForms?.Select || (grafanaUi as any).Select;\nconst Input = (grafanaUi as any).LegacyForms?.Input || (grafanaUi as any).Input;\n\nexport class ZabbixVariableQueryEditor extends PureComponent<VariableQueryProps, VariableQueryData> {\n  queryTypes: Array<SelectableValue<VariableQueryTypes>> = [\n    { value: VariableQueryTypes.Group, label: 'Group'},\n    { value: VariableQueryTypes.Host, label: 'Host' },\n    { value: VariableQueryTypes.Application, label: 'Application' },\n    { value: VariableQueryTypes.Item, label: 'Item' },\n    { value: VariableQueryTypes.ItemValues, label: 'Item values' },\n  ];\n\n  defaults: VariableQueryData = {\n    selectedQueryType: { value: VariableQueryTypes.Group, label: 'Group' },\n    queryType: VariableQueryTypes.Group,\n    group: '/.*/',\n    host: '',\n    application: '',\n    item: '',\n  };\n\n  constructor(props: VariableQueryProps) {\n    super(props);\n\n    if (this.props.query && typeof this.props.query === 'string') {\n      // Backward compatibility\n      const query = parseLegacyVariableQuery(this.props.query);\n      const selectedQueryType = this.getSelectedQueryType(query.queryType);\n      this.state = {\n        selectedQueryType,\n        legacyQuery: this.props.query,\n        ...query\n      };\n    } else if (this.props.query) {\n      const query = (this.props.query as VariableQuery);\n      const selectedQueryType = this.getSelectedQueryType(query.queryType);\n      this.state = {\n        ...this.defaults,\n        ...query,\n        selectedQueryType,\n      };\n    } else {\n      this.state = this.defaults;\n    }\n  }\n\n  getSelectedQueryType(queryType: VariableQueryTypes) {\n    return this.queryTypes.find(q => q.value === queryType);\n  }\n\n  handleQueryUpdate = (evt: React.ChangeEvent<HTMLInputElement>, prop: string) => {\n    const value = evt.currentTarget.value;\n    this.setState((prevState: VariableQueryData) => {\n      const newQuery = {\n        ...prevState,\n      };\n      newQuery[prop] = value;\n\n      return {\n        ...newQuery,\n      };\n    });\n  }\n\n  handleQueryChange = () => {\n    const { queryType, group, host, application, item } = this.state;\n    const queryModel = { queryType, group, host, application, item };\n    this.props.onChange(queryModel, `Zabbix - ${queryType}`);\n  }\n\n  handleQueryTypeChange = (selectedItem: SelectableValue<VariableQueryTypes>) => {\n    this.setState({\n      ...this.state,\n      selectedQueryType: selectedItem,\n      queryType: selectedItem.value,\n    });\n\n    const { group, host, application, item } = this.state;\n    const queryType = selectedItem.value;\n    const queryModel = { queryType, group, host, application, item };\n    this.props.onChange(queryModel, `Zabbix - ${queryType}`);\n  }\n\n  render() {\n    const { selectedQueryType, legacyQuery, group, host, application, item } = this.state;\n\n    return (\n      <>\n        <div className=\"gf-form max-width-21\">\n          <FormLabel width={10}>Query Type</FormLabel>\n          <Select\n            width={11}\n            value={selectedQueryType}\n            options={this.queryTypes}\n            onChange={this.handleQueryTypeChange}\n          />\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form max-width-30\">\n            <FormLabel width={10}>Group</FormLabel>\n            <ZabbixInput\n              value={group}\n              onChange={evt => this.handleQueryUpdate(evt, 'group')}\n              onBlur={this.handleQueryChange}\n            />\n          </div>\n          {selectedQueryType.value !== VariableQueryTypes.Group &&\n            <div className=\"gf-form max-width-30\">\n              <FormLabel width={10}>Host</FormLabel>\n              <ZabbixInput\n                value={host}\n                onChange={evt => this.handleQueryUpdate(evt, 'host')}\n                onBlur={this.handleQueryChange}\n              />\n            </div>\n          }\n        </div>\n        {(selectedQueryType.value === VariableQueryTypes.Application ||\n          selectedQueryType.value === VariableQueryTypes.Item ||\n          selectedQueryType.value === VariableQueryTypes.ItemValues) &&\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form max-width-30\">\n              <FormLabel width={10}>Application</FormLabel>\n              <ZabbixInput\n                value={application}\n                onChange={evt => this.handleQueryUpdate(evt, 'application')}\n                onBlur={this.handleQueryChange}\n              />\n            </div>\n            {(selectedQueryType.value === VariableQueryTypes.Item ||\n              selectedQueryType.value === VariableQueryTypes.ItemValues) &&\n              <div className=\"gf-form max-width-30\">\n                <FormLabel width={10}>Item</FormLabel>\n                <ZabbixInput\n                  value={item}\n                  onChange={evt => this.handleQueryUpdate(evt, 'item')}\n                  onBlur={this.handleQueryChange}\n                />\n              </div>\n            }\n          </div>\n        }\n\n        {legacyQuery &&\n          <div className=\"gf-form\">\n            <FormLabel width={10} tooltip=\"Original query string, read-only\">Legacy Query</FormLabel>\n            <Input\n              value={legacyQuery}\n              readOnly={true}\n            />\n          </div>\n        }\n      </>\n    );\n  }\n}\n","import _ from 'lodash';\nimport $ from 'jquery';\nimport angular from 'angular';\n\nclass ZabbixAlertingService {\n\n  /** @ngInject */\n  constructor(dashboardSrv) {\n    this.dashboardSrv = dashboardSrv;\n  }\n\n  isFullScreen() {\n    return this.getDashboardModel().meta.fullscreen;\n  }\n\n  setPanelAlertState(panelId, alertState) {\n    if (!alertState) {\n      return;\n    }\n\n    let panelIndex;\n    let panelContainers = _.filter($('.panel-container'), elem => {\n      return elem.clientHeight && elem.clientWidth;\n    });\n\n    let panelModels = this.getPanelModels();\n\n    if (this.isFullScreen()) {\n      panelIndex = 0;\n    } else {\n      panelIndex = _.findIndex(panelModels, panel => {\n        return panel.id === panelId;\n      });\n    }\n\n    if (panelIndex >= 0) {\n      let alertClass = \"panel-has-alert panel-alert-state--ok panel-alert-state--alerting\";\n      $(panelContainers[panelIndex]).removeClass(alertClass);\n\n      if (alertState) {\n        alertClass = \"panel-has-alert panel-alert-state--\" + alertState;\n        $(panelContainers[panelIndex]).addClass(alertClass);\n      }\n    }\n  }\n\n  getDashboardModel() {\n    return this.dashboardSrv.dash || this.dashboardSrv.dashboard;\n  }\n\n  getPanelModels() {\n    return _.filter(this.getDashboardModel().panels, panel => panel.type !== 'row');\n  }\n\n  getPanelModel(panelId) {\n    let panelModels = this.getPanelModels();\n\n    return _.find(panelModels, panel => {\n      return panel.id === panelId;\n    });\n  }\n\n  setPanelThreshold(panelId, threshold) {\n    let panel = this.getPanelModel(panelId);\n    let containsThreshold = _.find(panel.thresholds, {value: threshold});\n\n    if (panel && panel.type === \"graph\" && !containsThreshold) {\n      let thresholdOptions = {\n        colorMode : \"custom\",\n        fill : false,\n        line : true,\n        lineColor: \"rgb(255, 0, 0)\",\n        op: \"gt\",\n        value: threshold,\n        source: \"zabbix\"\n      };\n\n      panel.thresholds.push(thresholdOptions);\n    }\n  }\n\n  removeZabbixThreshold(panelId) {\n    let panel = this.getPanelModel(panelId);\n\n    if (panel && panel.type === \"graph\") {\n      panel.thresholds = _.filter(panel.thresholds, threshold => {\n        return threshold.source !== \"zabbix\";\n      });\n    }\n  }\n\n}\n\nangular\n  .module('grafana.services')\n  .service('zabbixAlertingSrv', ZabbixAlertingService);\n","import angular from 'angular';\nimport _ from 'lodash';\nimport $ from 'jquery';\nimport * as metricFunctions from './metricFunctions';\n\nangular\n  .module('grafana.directives')\n  .directive('addMetricFunction',\n\n  /** @ngInject */\n  function($compile) {\n    var inputTemplate = '<input type=\"text\"'+\n                          ' class=\"gf-form-input\"' +\n                          ' spellcheck=\"false\" style=\"display:none\"></input>';\n\n    var buttonTemplate = '<a  class=\"gf-form-label tight-form-func dropdown-toggle query-part\"' +\n                            ' tabindex=\"1\" gf-dropdown=\"functionMenu\" data-toggle=\"dropdown\">' +\n                            '<i class=\"fa fa-plus\"></i></a>';\n\n    return {\n      link: function($scope, elem) {\n        var categories = metricFunctions.getCategories();\n        var allFunctions = getAllFunctionNames(categories);\n\n        $scope.functionMenu = createFunctionDropDownMenu(categories);\n\n        var $input = $(inputTemplate);\n        var $button = $(buttonTemplate);\n        $input.appendTo(elem);\n        $button.appendTo(elem);\n\n        $input.attr('data-provide', 'typeahead');\n        $input.typeahead({\n          source: allFunctions,\n          minLength: 1,\n          items: 10,\n          updater: function (value) {\n            var funcDef = metricFunctions.getFuncDef(value);\n            if (!funcDef) {\n              // try find close match\n              value = value.toLowerCase();\n              funcDef = _.find(allFunctions, function(funcName) {\n                return funcName.toLowerCase().indexOf(value) === 0;\n              });\n\n              if (!funcDef) { return; }\n            }\n\n            $scope.$apply(function() {\n              $scope.ctrl.addFunction(funcDef);\n            });\n\n            $input.trigger('blur');\n            return '';\n          }\n        });\n\n        $button.click(function() {\n          $button.hide();\n          $input.show();\n          $input.focus();\n        });\n\n        $input.keyup(function() {\n          elem.toggleClass('open', $input.val() === '');\n        });\n\n        $input.blur(function() {\n          // clicking the function dropdown menu won't\n          // work if you remove class at once\n          setTimeout(function() {\n            $input.val('');\n            $input.hide();\n            $button.show();\n            elem.removeClass('open');\n          }, 200);\n        });\n\n        $compile(elem.contents())($scope);\n      }\n    };\n  });\n\nfunction getAllFunctionNames(categories) {\n  return _.reduce(categories, function(list, category) {\n    _.each(category, function(func) {\n      list.push(func.name);\n    });\n    return list;\n  }, []);\n}\n\nfunction createFunctionDropDownMenu(categories) {\n  return _.map(categories, function(list, category) {\n    return {\n      text: category,\n      submenu: _.map(list, function(value) {\n        return {\n          text: value.name,\n          click: \"ctrl.addFunction('\" + value.name + \"')\",\n        };\n      })\n    };\n  });\n}\n\n","import coreModule from 'grafana/app/core/core_module';\n\nexport function react2AngularDirective(name: string, component: any, options: any) {\n  coreModule.directive(name, [\n    'reactDirective',\n    reactDirective => {\n      return reactDirective(component, options);\n    },\n  ]);\n}\n","import React from 'react';\n\nconst DOCS_FUNC_REF_URL = 'https://alexanderzobnin.github.io/grafana-zabbix/reference/functions/';\n\nexport interface FunctionDescriptor {\n  text: string;\n  params: string[];\n  def: {\n    category: string;\n    defaultParams: string[];\n    description?: string;\n    fake: boolean;\n    name: string;\n    params: string[];\n  };\n}\n\nexport interface FunctionEditorControlsProps {\n  onMoveLeft: (func: FunctionDescriptor) => void;\n  onMoveRight: (func: FunctionDescriptor) => void;\n  onRemove: (func: FunctionDescriptor) => void;\n}\n\nconst FunctionHelpButton = (props: { description: string; name: string; onDescriptionShow: () => void }) => {\n  if (props.description) {\n    return <span className=\"pointer fa fa-question-circle\" onClick={props.onDescriptionShow} />;\n  }\n\n  return (\n    <span\n      className=\"pointer fa fa-question-circle\"\n      onClick={() => {\n        window.open(\n          DOCS_FUNC_REF_URL + '#' + props.name,\n          '_blank'\n        );\n      }}\n    />\n  );\n};\n\nexport const FunctionEditorControls = (\n  props: FunctionEditorControlsProps & {\n    func: FunctionDescriptor;\n    onDescriptionShow: () => void;\n  }\n) => {\n  const { func, onMoveLeft, onMoveRight, onRemove, onDescriptionShow } = props;\n  return (\n    <div\n      style={{\n        display: 'flex',\n        width: '60px',\n        justifyContent: 'space-between',\n      }}\n    >\n      <span className=\"pointer fa fa-arrow-left\" onClick={() => onMoveLeft(func)} />\n      <FunctionHelpButton\n        name={func.def.name}\n        description={func.def.description}\n        onDescriptionShow={onDescriptionShow}\n      />\n      <span className=\"pointer fa fa-remove\" onClick={() => onRemove(func)} />\n      <span className=\"pointer fa fa-arrow-right\" onClick={() => onMoveRight(func)} />\n    </div>\n  );\n};\n","import React from 'react';\n// import rst2html from 'rst2html';\nimport { FunctionDescriptor, FunctionEditorControlsProps, FunctionEditorControls } from './FunctionEditorControls';\n\n// @ts-ignore\nimport { PopoverController, Popover } from '@grafana/ui';\n\ninterface FunctionEditorProps extends FunctionEditorControlsProps {\n  func: FunctionDescriptor;\n}\n\ninterface FunctionEditorState {\n  showingDescription: boolean;\n}\n\nclass FunctionEditor extends React.PureComponent<FunctionEditorProps, FunctionEditorState> {\n  private triggerRef = React.createRef<HTMLSpanElement>();\n\n  constructor(props: FunctionEditorProps) {\n    super(props);\n\n    this.state = {\n      showingDescription: false,\n    };\n  }\n\n  renderContent = ({ updatePopperPosition }) => {\n    const {\n      onMoveLeft,\n      onMoveRight,\n      func: {\n        def: { name, description },\n      },\n    } = this.props;\n    const { showingDescription } = this.state;\n\n    if (showingDescription) {\n      return (\n        <div style={{ overflow: 'auto', maxHeight: '30rem', textAlign: 'left', fontWeight: 'normal' }}>\n          <h4 style={{ color: 'white' }}> {name} </h4>\n          <div>{description}</div>\n        </div>\n      );\n    }\n\n    return (\n      <FunctionEditorControls\n        {...this.props}\n        onMoveLeft={() => {\n          onMoveLeft(this.props.func);\n          updatePopperPosition();\n        }}\n        onMoveRight={() => {\n          onMoveRight(this.props.func);\n          updatePopperPosition();\n        }}\n        onDescriptionShow={() => {\n          this.setState({ showingDescription: true }, () => {\n            updatePopperPosition();\n          });\n        }}\n      />\n    );\n  };\n\n  render() {\n    return (\n      <PopoverController content={this.renderContent} placement=\"top\" hideAfter={300}>\n        {(showPopper, hidePopper, popperProps) => {\n          return (\n            <>\n              {this.triggerRef && (\n                <Popover\n                  {...popperProps}\n                  referenceElement={this.triggerRef.current}\n                  wrapperClassName=\"popper\"\n                  className=\"popper__background\"\n                  onMouseLeave={() => {\n                    this.setState({ showingDescription: false });\n                    hidePopper();\n                  }}\n                  onMouseEnter={showPopper}\n                  renderArrow={({ arrowProps, placement }) => (\n                    <div className=\"popper__arrow\" data-placement={placement} {...arrowProps} />\n                  )}\n                />\n              )}\n\n              <span\n                ref={this.triggerRef}\n                onClick={popperProps.show ? hidePopper : showPopper}\n                onMouseLeave={() => {\n                  hidePopper();\n                  this.setState({ showingDescription: false });\n                }}\n                style={{ cursor: 'pointer' }}\n              >\n                {this.props.func.def.name}\n              </span>\n            </>\n          );\n        }}\n      </PopoverController>\n    );\n  }\n}\n\nexport { FunctionEditor };\n","import coreModule from 'grafana/app/core/core_module';\nimport _ from 'lodash';\nimport $ from 'jquery';\nimport { react2AngularDirective } from './react2angular';\nimport { FunctionEditor } from './components/FunctionEditor';\n\n/** @ngInject */\nexport function zabbixFunctionEditor($compile, templateSrv) {\n  const funcSpanTemplate = `\n    <zbx-function-editor\n      func=\"func\"\n      onRemove=\"ctrl.handleRemoveFunction\"\n      onMoveLeft=\"ctrl.handleMoveLeft\"\n      onMoveRight=\"ctrl.handleMoveRight\"\n    /><span>(</span>\n  `;\n  const paramTemplate =\n    '<input type=\"text\" style=\"display:none\"' + ' class=\"input-small tight-form-func-param\"></input>';\n\n  return {\n    restrict: 'A',\n    link: function postLink($scope, elem) {\n      const $funcLink = $(funcSpanTemplate);\n      const ctrl = $scope.ctrl;\n      const func = $scope.func;\n      let scheduledRelink = false;\n      let paramCountAtLink = 0;\n      let cancelBlur = null;\n\n      ctrl.handleRemoveFunction = func => {\n        ctrl.removeFunction(func);\n      };\n\n      ctrl.handleMoveLeft = func => {\n        ctrl.moveFunction(func, -1);\n      };\n\n      ctrl.handleMoveRight = func => {\n        ctrl.moveFunction(func, 1);\n      };\n\n      function clickFuncParam(this: any, paramIndex) {\n        /*jshint validthis:true */\n\n        const $link = $(this);\n        const $comma = $link.prev('.comma');\n        const $input = $link.next();\n\n        $input.val(func.params[paramIndex]);\n\n        $comma.removeClass('query-part__last');\n        $link.hide();\n        $input.show();\n        $input.focus();\n        $input.select();\n\n        const typeahead = $input.data('typeahead');\n        if (typeahead) {\n          $input.val('');\n          typeahead.lookup();\n        }\n      }\n\n      function scheduledRelinkIfNeeded() {\n        if (paramCountAtLink === func.params.length) {\n          return;\n        }\n\n        if (!scheduledRelink) {\n          scheduledRelink = true;\n          setTimeout(() => {\n            relink();\n            scheduledRelink = false;\n          }, 200);\n        }\n      }\n\n      function paramDef(index) {\n        if (index < func.def.params.length) {\n          return func.def.params[index];\n        }\n        if ((_.last(func.def.params) as any).multiple) {\n          return _.assign({}, _.last(func.def.params), { optional: true });\n        }\n        return {};\n      }\n\n      function switchToLink(inputElem, paramIndex) {\n        /*jshint validthis:true */\n        const $input = $(inputElem);\n\n        clearTimeout(cancelBlur);\n        cancelBlur = null;\n\n        const $link = $input.prev();\n        const $comma = $link.prev('.comma');\n        const newValue = $input.val();\n\n        // remove optional empty params\n        if (newValue !== '' || paramDef(paramIndex).optional) {\n          func.updateParam(newValue, paramIndex);\n          $link.html(newValue ? templateSrv.highlightVariablesAsHtml(newValue) : '&nbsp;');\n        }\n\n        scheduledRelinkIfNeeded();\n\n        $scope.$apply(() => {\n          ctrl.targetChanged();\n        });\n\n        if ($link.hasClass('query-part__last') && newValue === '') {\n          $comma.addClass('query-part__last');\n        } else {\n          $link.removeClass('query-part__last');\n        }\n\n        $input.hide();\n        $link.show();\n      }\n\n      // this = input element\n      function inputBlur(this: any, paramIndex) {\n        /*jshint validthis:true */\n        const inputElem = this;\n        // happens long before the click event on the typeahead options\n        // need to have long delay because the blur\n        cancelBlur = setTimeout(() => {\n          switchToLink(inputElem, paramIndex);\n        }, 200);\n      }\n\n      function inputKeyPress(this: any, paramIndex, e) {\n        /*jshint validthis:true */\n        if (e.which === 13) {\n          $(this).blur();\n        }\n      }\n\n      function inputKeyDown(this: any) {\n        /*jshint validthis:true */\n        this.style.width = (3 + this.value.length) * 8 + 'px';\n      }\n\n      function addTypeahead($input, paramIndex) {\n        $input.attr('data-provide', 'typeahead');\n\n        let options = paramDef(paramIndex).options;\n        if (paramDef(paramIndex).type === 'int' || paramDef(paramIndex).type === 'float') {\n          options = _.map(options, val => {\n            return val.toString();\n          });\n        }\n\n        $input.typeahead({\n          source: options,\n          minLength: 0,\n          items: 20,\n          updater: value => {\n            $input.val(value);\n            switchToLink($input[0], paramIndex);\n            return value;\n          },\n        });\n\n        const typeahead = $input.data('typeahead');\n        typeahead.lookup = function() {\n          this.query = this.$element.val() || '';\n          return this.process(this.source);\n        };\n      }\n\n      function addElementsAndCompile() {\n        $funcLink.appendTo(elem);\n\n        const defParams: any = _.clone(func.def.params);\n        const lastParam: any = _.last(func.def.params);\n\n        while (func.params.length >= defParams.length && lastParam && lastParam.multiple) {\n          defParams.push(_.assign({}, lastParam, { optional: true }));\n        }\n\n        _.each(defParams, (param: any, index: number) => {\n          if (param.optional && func.params.length < index) {\n            return false;\n          }\n\n          let paramValue = templateSrv.highlightVariablesAsHtml(func.params[index]);\n          const hasValue = paramValue !== null && paramValue !== undefined;\n\n          const last = index >= func.params.length - 1 && param.optional && !hasValue;\n          if (last && param.multiple) {\n            paramValue = '+';\n          }\n\n          if (index > 0) {\n            $('<span class=\"comma' + (last ? ' query-part__last' : '') + '\">, </span>').appendTo(elem);\n          }\n\n          const $paramLink = $(\n            '<a ng-click=\"\" class=\"graphite-func-param-link' +\n              (last ? ' query-part__last' : '') +\n              '\">' +\n              (hasValue ? paramValue : '&nbsp;') +\n              '</a>'\n          );\n          const $input = $(paramTemplate);\n          $input.attr('placeholder', param.name);\n\n          paramCountAtLink++;\n\n          $paramLink.appendTo(elem);\n          $input.appendTo(elem);\n\n          $input.blur(_.partial(inputBlur, index));\n          $input.keyup(inputKeyDown);\n          $input.keypress(_.partial(inputKeyPress, index));\n          $paramLink.click(_.partial(clickFuncParam, index));\n\n          if (param.options) {\n            addTypeahead($input, index);\n          }\n\n          return true;\n        });\n\n        $('<span>)</span>').appendTo(elem);\n\n        $compile(elem.contents())($scope);\n      }\n\n      function ifJustAddedFocusFirstParam() {\n        if ($scope.func.added) {\n          $scope.func.added = false;\n          setTimeout(() => {\n            elem\n              .find('.graphite-func-param-link')\n              .first()\n              .click();\n          }, 10);\n        }\n      }\n\n      function relink() {\n        elem.children().remove();\n        addElementsAndCompile();\n        ifJustAddedFocusFirstParam();\n      }\n\n      relink();\n    },\n  };\n}\n\ncoreModule.directive('zabbixFunctionEditor', zabbixFunctionEditor);\n\nreact2AngularDirective('zbxFunctionEditor', FunctionEditor, ['func', 'onRemove', 'onMoveLeft', 'onMoveRight']);\n","import { loadPluginCss } from 'grafana/app/plugins/sdk';\nimport { ZabbixDatasource } from './datasource';\nimport { ZabbixQueryController } from './query.controller';\nimport { ZabbixDSConfigController } from './config.controller';\nimport { ZabbixVariableQueryEditor } from './components/VariableQueryEditor';\nimport './zabbixAlerting.service.js';\nimport './add-metric-function.directive';\nimport './metric-function-editor.directive';\n\nclass ZabbixQueryOptionsController {\n  static templateUrl = 'datasource-zabbix/partials/query.options.html';\n}\n\nclass ZabbixAnnotationsQueryController {\n  static templateUrl = 'datasource-zabbix/partials/annotations.editor.html';\n}\n\nZabbixQueryController.templateUrl = 'datasource-zabbix/partials/query.editor.html';\nZabbixDSConfigController.templateUrl = 'datasource-zabbix/partials/config.html';\n\nloadPluginCss({\n  dark: 'plugins/alexanderzobnin-zabbix-app/css/grafana-zabbix.dark.css',\n  light: 'plugins/alexanderzobnin-zabbix-app/css/grafana-zabbix.light.css'\n});\n\nexport {\n  ZabbixDatasource as Datasource,\n  ZabbixDSConfigController as ConfigCtrl,\n  ZabbixQueryController as QueryCtrl,\n  ZabbixQueryOptionsController as QueryOptionsCtrl,\n  ZabbixAnnotationsQueryController as AnnotationsQueryCtrl,\n  ZabbixVariableQueryEditor as VariableQueryEditor,\n};\n"],"sourceRoot":""}